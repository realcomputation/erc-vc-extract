\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{mathpartir}
\usepackage{bm}
\usepackage{bussproofs}
\usepackage{color}

\usepackage{hyperref}

\newtheorem{theorem}{Theorem}

\newcommand{\Martin}[1]{\textcolor{blue}{#1}}
\newcommand{\Sewon}[1]{\textcolor{red}{#1}}

\newcommand{\dreal}{\textbf{R}}
\newcommand{\dint}{\textbf{Z}}
\newcommand{\treal}{\textbf{Rterm}}
\newcommand{\tint}{\textbf{Zterm}}
\newcommand{\tinta}{\textbf{Z}^*\text{term}}
\newcommand{\select}{\text{select}}
\newcommand{\test}[1]{\text{test}(#1)}
\newcommand{\prog}{\boldsymbol{p}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket }
\newcommand{\trans}[1]{\mathcal{T}( #1) }
\newcommand{\transh}[1]{\mathcal{H}( #1) }
\newcommand{\asser}[1]{ \;\pmb{[\vphantom{\frac{1}{2}}} #1 \pmb{\vphantom{\frac{1}{2}}]\;}
 }


\begin{document}
ERC is a programming language which abstracts exact real computation languages such as 
\texttt{iRRAM}, \texttt{AERN}2, $\cdots$. 
The purpose of the supplement is to formally construct ERC language and its verification rules
thus that it can be implemented.

\section{Syntax}
\label{s:syntax}
ERC is an imperative language that has distinction between statements and terms.
Data types of ERC are defined as follow:
\[
\tau := \textbf{R} \;|\; \textbf{Z} \;|\; \textbf{R}(n)\;|\;\textbf{Z}(n)
\]

$\textbf{R}\;(\textbf{R}(n))$ represents real numbers (arrays of size $n$) and
$\textbf{Z}\;(\textbf{Z}(n))$ represents integer numbers (arrays of size $n$).

ERC supports modularization by introducing a set of special function symbols.
It can be understood as a predefined set of ERC programs whose properties are known. 
We write $\mathcal{G}$ to be a set of integer valued multifunction symbols and
$\mathcal{F}$ to be a set of real valued function symbols.

\Martin{[I am confused: $\mathcal{F}$ is first a set of functions, then a function from string (?)
to a list (?) of data types, then takes $f$ (which is not a string) as argument!]}
\Sewon{[I want $\mathcal{F}$ to store information of assumed functions including its domain instead of 
introducing another symbol which stores the information of the assumed functions]}

$\mathcal{G}$  ($\mathcal{F}$) is thought as a function from string to a list of data types.
For example, if $\mathcal{F}(f) = \dreal :: \dreal :: \dreal :: \texttt{nil}$, it means that $f$ is a predefined 
function symbol from $\dreal \times \dreal \times \dreal$ to $\dint$.
The set $\mathcal{G}$ and $\mathcal{F}$ cannot be modified inside of any ERC program, 
hence it can be thought as constants. 
Function symbols stored in $\mathcal{G}$ and $\mathcal{F}$ not being duplicated is assumed.

\vspace{1em}

Terms are not strictly separated by their types: 
we do not have \textbf{Rterm} and \textbf{Zterm} distinction;
hence, both real addition and integer addition share their operator symbol $+$.
The aim is to design ERC not to have any ambiguity in its type inference; 
given any context, it should be possible to decide a term's type.
Type checking is introduced in the next section.

Though a term itself does not come with its type, 
in order to make it easier to be understood, 
we write $z, z_i$ to denote terms which should be typed \textbf{Z}, and
$x, y, x_i$ to denote terms which should be typed \textbf{R}.
Terms are defined inductively as follow:

\begin{flalign*}
&T, t, z,z_i,x,y,x_i :=  &\\
&\quad\quad
|\;\cdots -1,0,1\cdots \quad \text{integer constants} \quad
|\;\cdots -1.0,0.0,1.0\cdots \quad \text{real constants}&\\
&\quad\quad
|\;v \quad \text{variable}\quad
|\quad T[z] \quad \text{array access} \quad
|\quad x > y \quad \text{real comparison}\;\;  &\\
&\quad\quad
|\;f(t) \quad \text{function application}\quad
|\quad t_1 + t_2 \quad \text{addition} \quad
|\quad -t \quad \text{additive inversion}&\\
&\quad\quad
|\;x * y \quad \text{multiplication}\quad
|\quad /x \quad \text{multiplicative inversion}\quad
|\quad\max(t_1, t_2) \quad \text{maximum}&\\
&\quad\quad
|\;\neg z_1 \quad\text{boolean negation} \quad
|\quad z_1 \land z_2 \quad\text{boolean conjunction}&\\
&\quad\quad
|\; z_1 \lor z_2 \quad\text{boolean disjunction} \quad
|\quad \select(z_0, z_1) \quad\text{multivalued select}&\\
&\quad\quad
|\; z\;?\; x : y \quad\text{conditional}\quad
|\quad \iota(z) \quad \text{precision embedding}&
\end{flalign*}

While a term represents values of a certain type,
statements provide means of computation.
Statements in ERC are constructed as follow:
\begin{flalign*}
&S, S_1, S_2 := & \\
&\quad\quad
|\;\epsilon\quad \text{Skip}&\\
&\quad\quad
|\;v := t \quad \text{Variable Assignment}&\\
&\quad\quad
|\;T[z] := t \quad \text{Array Assignment}&\\
&\quad\quad
|\;\textbf{newvar}\; v := t \quad \text{New Variable}&\\
&\quad\quad
|\;S_1;\;S_2 \quad \text{Sequence}&\\
&\quad\quad
|\;\textbf{if}\; z \;\textbf{then}\; S_1 \;\textbf{else}\; S_2 \quad \text{Branching}\;\; &\\
&\quad\quad
|\;\textbf{while}\;z\;\textbf{do}\;S \quad \text{Loop}&\\
\end{flalign*}

Having data types, terms and statements defined, 
we can finally define what a program in ERC is:
\begin{flalign*}
&\prog := &\\
&\qquad\textbf{input}\;v_1 : \tau_1, v_2 : \tau_, \cdots, v_n : \tau_n &\\
&\qquad S &\\
&\qquad\textbf{return}\;t& 
\end{flalign*}

\section{Type Checking}
\subsection{Type of Terms}
Context is a mapping from a set of variables to their corresponding types; e.g., $\Gamma(x)=\dreal$.
Well--typedness of a term $t$ to $\tau$ under a context $\Gamma$ is written as $\Gamma \vdash t :\tau$.
The below shows ERC's type inference rules. 
Type checking, which is a function that tells whether a term $t$ is well--typed and, if so, what type it has,
 under a context $\Gamma$ is well--defined and computable.

\vspace{1em}

\begin{mathpar}
\infer{\Gamma \vdash c : \dint}{%
}
\and
\infer{\Gamma \vdash c.0 : \dreal}{%
}
\and
\infer{\Gamma \vdash v : \tau}{%
v \in \text{dom}(\Gamma)&
\Gamma(v) = \tau
}
\and
\infer{\Gamma \vdash T[z] : \tau}{%
\Gamma \vdash z : \dint &
T \in \text{dom}(\Gamma)&
\Gamma(T) = \tau(n)
}
\and
\infer{\Gamma \vdash x>y : \dint}{%
\Gamma \vdash x, y : \dreal
}
\and
\infer{\Gamma \vdash f(t_1, \cdots, t_n) : \dint}{%
f \in \text{dom}(G)&
\Gamma \vdash t_i : \pi_i(G(f))
}
\and
\infer{\Gamma \vdash f(t_1, \cdots, t_n) : \dreal}{%
f \in \text{dom}(F)&
\Gamma \vdash t_i : \pi_i(F(f))
}
\and
\infer{\Gamma \vdash t_1 + t_2 : \tau}{%
\tau := \dreal\;\text{or}\;\dint&
\Gamma \vdash t_1, t_2 : \tau
}
\and
\infer{\Gamma \vdash - t : \tau}{%
\tau := \dreal\;\text{or}\;\dint&
\Gamma \vdash t : \tau
}
\and
\infer{\Gamma \vdash x *  y : \dreal}{%
\Gamma \vdash x, y: \dreal
}
\and
\infer{\Gamma \vdash /x : \dreal}{%
\Gamma \vdash x : \dreal
}
\and
\infer{\Gamma\vdash \max(t_1, t_2) : \tau}{%
\tau := \dreal\;\text{or}\;\dint&
\Gamma \vdash t_1, t_2 : \tau
}
\and
\infer{\Gamma \vdash \neg z : \dint}{%
\Gamma \vdash z: \dint
}
\and
\infer{\Gamma \vdash z_1 \land z_2 : \dint}{%
\Gamma \vdash z_1, z_2: \dint
}
\and
\infer{\Gamma \vdash z_1 \lor z_2 : \dint}{%
\Gamma \vdash z_1, z_2: \dint
}
\and
\infer{\Gamma \vdash \select(z_0, z_1) : \dint}{%
\Gamma \vdash z_1, z_2: \dint
}
\and
\infer{\Gamma \vdash (z \;?\; x : y) : \dreal}{%
\Gamma \vdash z : \dint &
\Gamma \vdash x, y : \dreal
}
\and
\infer{\Gamma \vdash  \iota(z) : \dreal}{%
\Gamma \vdash z: \dint
}
\end{mathpar}

\vspace{1em}



\subsection{Well-typed Statements}
Unlike terms, a statement in ERC may modify contexts. Let us denote 
a statement $S$ under a context $\Gamma$ being well--typed 
and yielding a new context $\Gamma'$ as follow:
\[
\Gamma \vdash S \triangleright \Gamma'
\]
Well--typedness of a statement is defined with the inference rules as follow:

\vspace{1em}
\begin{mathpar}
\infer{\Gamma \vdash \epsilon  \triangleright \Gamma}{%
}
\and
\infer{\Gamma \vdash v:=t  \triangleright \Gamma}{%
\Gamma \vdash t : \tau &
\Gamma(v) = \tau &
}
\and
\infer{\Gamma \vdash T[z]:=t  \triangleright \Gamma}{%
\Gamma \vdash z : \dint &
\Gamma \vdash t : \tau &
\Gamma(T) = \tau(n) &
\tau=\dint \;\text{or}\; \dreal 
}
\and
\infer{\Gamma \vdash \textbf{newvar}\;v:=t\; \triangleright \Gamma \cup t(v\mapsto \tau)}{%
v\not\in \text{dom}(\Gamma)&
\Gamma \vdash t : \tau
}
\and
\infer{\Gamma \vdash S_1;S_2 \triangleright \Gamma_2}{%
\Gamma \vdash S_1 \triangleright \Gamma_1 &
\Gamma_1 \vdash S_2 \triangleright \Gamma_2
}
\and
\infer{\Gamma \vdash \textbf{if}\;z\;\textbf{then}\;S_1 \;\textbf{else}\;S_2 \triangleright \Gamma}{%
\Gamma \vdash z : \dint &
\Gamma \vdash S_1 \triangleright \Gamma &
\Gamma \vdash S_2 \triangleright \Gamma
}
\and
\infer{\Gamma \vdash \textbf{while}\;z\;\textbf{do}\;S  \triangleright \Gamma}{%
\Gamma \vdash z : \dint &
\Gamma \vdash S \triangleright \Gamma
}
\end{mathpar}
\vspace{1em}

Note that a new variable cannot be declared inside of a branching or a loop.
Showing the type checking of a statement being well--defined and computable 
can be done by directly constructing it,
using the recursion  above.

\subsection{Type of Program}
An ERC program 
\begin{align*}
\prog := &\\
&\textbf{input}\;v_1 : \tau_1, v_2 : \tau_, \cdots, v_n : \tau_n \\
&S \\
&\textbf{return}\;t 
\end{align*}
is well--typed if, 
\[
 \Gamma_0 \vdash S \triangleright \Gamma \quad\text{and}\quad \Gamma \vdash t : \tau
\]
where $\Gamma_0 := \cup_i(v_i \mapsto \tau_i)$. We say that the ERC program 
$\prog$ is a function from $\tau_1\times\cdots\times\tau_n$ to $\tau$.

\section{Denotational Semantics}
\label{s:semantics}

Well--typed terms, statements and programs have semantics which are
mathematical meanings of the objects in the programming language.

Semantics of data types are 
$\sem{\dreal}=\mathbb{R}$ a set of real numbers, 
$\sem{\dreal(n)} = \mathbb{R}^n$ a set of real vectors of dimension $n$,
$\sem{\dint} = \mathbb{Z}$ a set of integers and
$\sem{\dint(n)} = \mathbb{Z}^n$ a set of integer vectors of dimension $n$,

Semantic of a context is a set of assignments of its defined variables 
into their values in proper types;
for example, if $\Gamma = x\mapsto\dreal$, then $\sem{\Gamma} := \{x\mapsto w : w\in \mathbb{R}\}$.
An element $\sigma\in\sem{\Gamma}$ of the semantic of a context is called state, 
which is a specific assignment of variables defined in $\Gamma$.

We use the Powerdomain discovered by Plotkin 1976 to a space of our semantics \cite{Plotkin1976}:
For any set $A$, $A_\bot$ is a poset where $\bot \sqsubseteq a$ for all $a\in A$ and any distinct
elements of $A$ not comparable.
 For any set $A$, we define $\mathcal{P}(A_\bot)$  a set of nonempty subsets of $A$ 
with extra condition that for any infinite $B \in \mathcal{P}(A_\bot)$, $\bot\in B$.
We say a member of $\mathcal{P}(A_\bot)$ is proper if it does not contain $\bot$.
Egli--Milner ordering gives order in $\mathcal{P}(A_\bot)$ such that
$p \sqsubseteq q$ if $\bot\in p$ and $p\subseteq q\cup\{\bot\}$, otherwise $p=q$; the
ordering makes $\mathcal{P}(A_\bot)$ a domain .

\subsection{Semantic of Terms}
Considering the multivalue concept in ERC, a term's meaning under a state is a subset of a certain set;
e.g., for a well--typed term $\Gamma\vdash t : \dint$, its semantic under a state $\sigma$ is a subset
of integers;
semantic of a well--typed term is a function of the following type: 
\[\sem{\Gamma\vdash t : \tau} : \sem{\Gamma} \to \mathcal{P}(\sem{\tau}_\bot)\]

As is mentioned, semantic only is defined to well--typed terms. 
However, to ease describing, we often omit $\Gamma, \tau$ and 
simply write $\sem{t}$ instead of $\sem{\Gamma\vdash t:\tau}$.
The semantic of well--typed terms is defined as follow:

\begin{flalign*}
%constants
&\sem{\Gamma \vdash c : \dint}\sigma = \{c\}&\\
&\sem{\Gamma \vdash c.0 : \dreal}\sigma = \{ c \}&\\
%variable
&\sem{\Gamma \vdash v : \tau}\sigma = \{ \sigma(v) \}&\\
%array access
&\sem{\Gamma \vdash T[z] : \tau}\sigma = 
\bigcup_{n\in\sem{z}\sigma} 
\begin{cases}
\{\pi_n(\sigma(T))\} & \text{if}\; 0\leq n < \dim(\Gamma(T))\\
\{\bot\} & \text{else}
\end{cases}&\\
%comparison
&\sem{\Gamma \vdash x > y : \dint}\sigma = 
\bigcup_{x'\in\sem{x}\sigma\;y'\in\sem{y}\sigma}\begin{cases}
\{1\} &\text{if}\; x' > y' \\
\{0\} &\text{if}\; x' < y' \\
\{\bot\} &\text{if}\; x'=y'\;\text{or}\; x = \bot \;\text{or}\; y = \bot
\end{cases}&\\
%function app multi
&\sem{\Gamma \vdash f(t_1, \cdots, t_n) : \dint}\sigma = 
\bigcup_{w_i\in\sem{t_i}\sigma}
\begin{cases}
f(w_1,\cdots,w_n) &\text{if}\; w_i\neq\bot\;\text{and}\; (w_1,\cdots,w_n)\in\text{dom}(f) \\
\{\bot\} &\text{else}
\end{cases}&\\
%function app single
&\sem{\Gamma \vdash f(t_1, \cdots, t_n) : \dreal}\sigma = 
\bigcup_{w_i\in\sem{t_i}\sigma}
\begin{cases}
\{f(w_1,\cdots,w_n)\} &\text{if}\; w_i\neq\bot\;\text{and}\; (w_1,\cdots,w_n)\in\text{dom}(f) \\
\{\bot\} &\text{else}
\end{cases}&\\
%arithmetics 
&\sem{\Gamma \vdash t_1 + t_2 :\tau}\sigma =
\bigcup_{w_1\in\sem{t_1}\sigma\;w_2\in\sem{t_2}\sigma}\{w_1\tilde+ w_2\}&\\
&\sem{\Gamma \vdash -t:\tau}\sigma = 
\bigcup_{w\in\sem{t}\sigma}\{\tilde- w\}&\\
&\sem{\Gamma \vdash x * y :\dreal}\sigma = 
\bigcup_{w_1\in\sem{t_1}\sigma\;w_2\in\sem{t_2}\sigma}\{w_1\tilde\times w_2\}&\\
\end{flalign*}
\begin{flalign*}
&\sem{\Gamma \vdash /x : \dreal}\sigma = 
\bigcup_{w\in\sem{t}\sigma}
\begin{cases}
\{ 1/w \}&\text{if}\; w\neq\bot,\;w\neq0\\
\{\bot\} &\text{else}
\end{cases}&\\
&\sem{\Gamma \vdash \max(t_1, t_2) : \tau}\sigma = 
\bigcup_{w_1\in\sem{t_1}\sigma\;w_2\in\sem{t_2}\sigma}\{\tilde{\text{max}}(w_1, w_2)\}&\\
%boolean operators
&\sem{\Gamma \vdash \neg z : \dint}\sigma =  
\bigcup_{w \in \sem{z}\sigma}\begin{cases}
\{1\} &\text{if}\;w=1\\
\{0\} &\text{if}\;w\neq0\;w\neq\bot\\
\{\bot\} &\text{else}
\end{cases}&\\
&\sem{\Gamma \vdash z_1 \land z_2 : \dint}\sigma =  
\bigcup_{w_1\in\sem{z_1}\sigma\;w_2\in\sem{z_2}\sigma}
\begin{cases}
\{1\}&\text{if}\; w_1,w_2 = 1\\
\{0\}&\text{if}\; w_1=0\;\text{or}\;w_2=0\\
\{\bot\}&\text{else}
\end{cases}&\\
&\sem{\Gamma \vdash z_1 \lor z_2 : \dint}\sigma =  
\bigcup_{w_1\in\sem{z_1}\sigma\;w_2\in\sem{z_2}\sigma}
\begin{cases}
\{1\}&\text{if}\; w_1=1\;\text{or}\;w_2=1\\
\{0\}&\text{if}\; w_1,w_2 = 0\\
\{\bot\}&\text{else}
\end{cases}&\\
%select
&\sem{\Gamma \vdash \select(z_0, z_1) : \dint}\sigma = 
\bigcup_{b_0\in\sem{z_0}\sigma\;b_1\in\sem{z_1}\sigma}
\begin{cases}
\{0\} &\text{if}\; b_0 \neq \bot \\
\{1\} &\text{if}\; b_1 \neq \bot \\
\{\bot\} &\text{if}\; b_0= b_1 = \bot 
\end{cases}&\\
%conditional
&\sem{\Gamma \vdash (z \;?\; x : y) : \dreal} \sigma = 
\bigcup_{b\in\sem{z}\sigma}
\begin{cases}
\sem{x}\sigma &\text{if}\; b\neq 0 \land b\neq \bot \\
\sem{y}\sigma &\text{if}\; b= 0\\
\sem{x}\sigma \odot \sem{y}\sigma &\text{else.}
\end{cases}&\\
%embedding
&\sem{\Gamma \vdash \iota(z) : \dreal}\sigma =  
\bigcup_{w\in\sem{z}\sigma}\begin{cases}
\{2^w\}&\text{if}\; w\neq\bot \\
\{\bot\} &\text{else}
\end{cases}&
\end{flalign*}

For an operation $op$, we write $\tilde{op}$ which extends the co/--domain of $op$ 
so that  it returns $\bot$ when at least one of its arguments turn out to be $\bot$; otherwise,
it remains the same. For two sets $U, V$ the operation $\odot$ on those is defined as follow:

\[
U \odot V := 
\begin{cases}
U &\text{if}\; \bot\not\in U=V\;\;|U|=1\\
\{\bot\} &\text{else.}
\end{cases}
\]

\subsection{Semantic of Statements}
\label{ss:semstatement}
Semantic of statements is a state transformer.
Considering multivaluedness in ERC,
we let the semantic of a well--typed statement to be a function from
the set of states to the restricted powerset of the resulting states:
\[
\sem{\Gamma \vdash S \triangleright \Gamma'} : \sem{\Gamma} \to \mathcal{P}(\sem{\Gamma'}_\bot)
\]
Semantics of the statements except for the while loop are defined as follow:
\begin{flalign*}
% empty
&\sem{\Gamma\vdash \epsilon \triangleright \Gamma}\sigma = \{\sigma\} &\\
% var assignment
&\sem{\Gamma \vdash v:=t \triangleright \Gamma} \sigma = 
\bigcup_{w\in\sem{t}\sigma}
\begin{cases}
\{\sigma[v\mapsto w]\} &\text{if}\; w \neq \bot\\
\{\bot\} &\text{else}
\end{cases}&\\
% array assignment
&\sem{\Gamma \vdash T[z]:=t \triangleright \Gamma} \sigma = 
\bigcup_{n\in\sem{z}\sigma\;w\in\sem{t}\sigma}
\begin{cases}
\{\sigma[T \twoheadrightarrow_n w]\} &\text{if}\; 0\leq n<d \;\text{and}\; w\neq \bot \\
\{\bot\} &\text{else.}
\end{cases}
&\\
% new variable
&\sem{\Gamma \vdash \textbf{newvar}\;v:=t\; \triangleright \Gamma'} \sigma =
\bigcup_{w\in\sem{t}\sigma}
\begin{cases}
\{\sigma\cup(v\mapsto w)\} &\text{if}\; w \neq \bot\\
\{\bot\} &\text{else}
\end{cases}&\\
% sequence
&\sem{\Gamma \vdash S_1; S_2 \triangleright \Gamma'} \sigma =
\bigcup_{\delta\in\sem{S_1}\sigma}
\begin{cases}
\sem{S_2}\delta &\text{if}\; \delta\neq\bot\\
\{\bot\} &\text{else}
\end{cases}&\\
%%%%%%%%%%
% conditional
&\sem{\Gamma \vdash\textbf{if}\;z\;\textbf{then}\;S_1\;\textbf{else}\;S_2 \triangleright \Gamma} \sigma =
\bigcup_{b\in\sem{z}\sigma}
\begin{cases}
\sem{S_1}\delta &\text{if}\; b \neq \bot,\;b\neq0\\
\sem{S_2}\delta &\text{if}\; b = 0\\
\{\bot\} &\text{if}\; b= \bot
\end{cases}
\end{flalign*}
%%%%%%%%%%
% while statement in recursive form
%&\sem{\Gamma \vdash\textbf{while}\;z\;\textbf{do}\;S \triangleright \Gamma} \sigma =
%\sem{\Gamma \vdash\textbf{if}\;z\;\textbf{then}\;S\;\textbf{else} \;\epsilon\;;\;\textbf{while}\;z\;\textbf{do}\;S \triangleright \Gamma} \sigma 
%=
%\{
%\}&
%\end{flalign*}
$\sigma[T\twoheadrightarrow_n w]$ is to substitute the $n$'th element of $T$ in the state $\sigma$
if $n$ is in proper range of $T$'s dimension, otherwise be $\bot$.

Defining the semantic of the while loop is a little subtle.
However, luckily the domain that we are working on, $\mathcal{P}(\sem{\Gamma}_\bot)$, 
is the famous powerdomain for bounded nondeterminism.
Therefore, equipping point--wise ordering, with using the fixed point theorem,
we can define the semantic of while loop;
consider the recursive semantic equation of the while loop:
\begin{align*}
\sem{\textbf{while}\;z\;\textbf{do}\;S}\sigma &= 
\sem{\textbf{if}\;z\;\textbf{then}\;S;(\textbf{while}\;z\;\textbf{do}\;S)\;\textbf{else}\;\epsilon}\sigma \\
&=\bigcup_{b\in\sem{z}\sigma}
\begin{cases}
\sem{S;(\textbf{while}\;z\;\textbf{do}\;S)}\sigma \\
\{\sigma\}\\
\{\bot\}
\end{cases} \\
&=\bigcup_{b\in\sem{z}\sigma\;\delta\in\sem{S}\sigma}
\begin{cases}
\sem{\textbf{while}\;z\;\textbf{do}\;S}\delta &\text{if}\; \delta \neq \bot \;b\neq\bot\;b\neq0\\
\{\sigma\} &\text{if}\; b = 0\\
\{\bot\} &\text{else}
\end{cases}
\end{align*}

Hence, we can define the operator of type 
$(\sem{\Gamma} \to \mathcal{P}(\sem{\Gamma}_\bot)) \to (\sem{\Gamma} \to \mathcal{P}(\sem{\Gamma}_\bot))$
as follow:
\[
\mathcal{F}_{z,S}(f) = \lambda \sigma.\;  
\bigcup_{b\in\sem{z}\sigma\;\delta\in\sem{S}\sigma}
\begin{cases}
f(\delta)&\text{if}\; \delta,\;b \neq \bot\;\text{and}\;b\neq0\\
\{\sigma\} &\text{if}\; b = 0\\
\{\bot\} &\text{else}
\end{cases}
\]
Proof of monotonicity and continuity of $\mathcal{F}_{z,S}$ will follow the proof used to define
semantic of bounded nondeterminism in Dijkstra's guarded command \cite{Dijkstra};
(see its proof in the classic textbook of J. Reynold \cite{reynolds1998}.)

The semantic of the while loop can be defined as 
the least fixed point of the operator:
\[
\sem{\textbf{while}\;z\;\textbf{do}\;S}\sigma = \mathcal{F}_{z,S}^\infty(\bot) 
\]
Or, consider the chain:
\[
\omega_0 := \lambda \sigma.\; \bot \sqsubseteq \omega_1 \cdots \sqsubseteq \omega_{i+1} := \mathcal{F}_{z,S}(\omega_i) \sqsubseteq \cdots
\]
where $\sem{\textbf{while}\;z\;\textbf{do}\;S}\sigma = \bigsqcup_\infty \omega_i \sigma$.

\subsection{Semantic of Programs}
Having semantics of the statements defined, 
we can define semantics of the ERC programs.
Recall that a ERC program is constructed with the following format:
\begin{flalign*}
&\prog := &\\
&\qquad\textbf{input}\;v_1 : \tau_1, v_2 : \tau_, \cdots, v_n : \tau_n &\\
&\qquad S &\\
&\qquad\textbf{return}\;t& 
\end{flalign*}

A well--typed program $\prog$ guarantees the following well--typedness:
$\Gamma_0 \vdash S \triangleright \Gamma$ and $\Gamma \vdash t : \tau$ 
where $\Gamma_0 := \cup_i (v_i\mapsto \tau_i)$ with some $\tau$.
The semantic of the program $\prog$ is a set--valued function 
\[
\sem{\prog} : \sem{\Gamma} \to \mathcal{P}(\sem{\tau}_\bot)
\]
such that 
\[\sem{\prog} := \lambda (x_1, \cdots, x_n).\;  \{\sigma : \sigma\in\sem{t}\delta \land \delta \in \sem{S}\cup_i(v_i\mapsto x_i)\}\]

We say the program $\sem{\prog}$ is total if does not contain $\bot$ for its any input values.
We say the program $\sem{\prog}$ is single--valued if 
for any of its input values, the output contains $\bot$ or is singleton.

\section{Verification}
Assertion is a logical predicate on a set of assignments $\sem{\Gamma}$.
A language used to define assertions is called assertion language.
In ERC, we let the first--order language on the two sorted structure (see Theorem \ref{}) to be 
the assertion language.

We let the function symbols to accompany with
a finite list of tuples of predicates;
for an example, if there is a function symbol $f:\tau_1\times\cdots\times\tau_d\to\tau$ in either $\mathcal{F}$ or $\mathcal{G}$ loaded to the language,
there exists $\{(\phi(f)_i, \psi(f)_i)\}$ where $\phi(f)_i$ is a predicate over $\sem{\tau_1}\times\cdots\times\sem{\tau_d}$ and
$\psi(f)_i$ is a predicate defined over $\sem{\tau}\times\sem{\tau_1}\times\cdots\times\sem{\tau_d}$.
The set of predicates defines \Martin{[No!}] the domain of the function and the function's properties on the domain:
\[
f(x_1,\cdots, x_d) \downarrow v \leftarrow \exists k.\; \phi(f)_k(x_1,\cdots, x_d) \land \forall k.\;
\phi(f)_k(x_1,\cdots, x_d) \to
\psi(v, x_1, \cdots, x_d)
\]
\Martin{[(How) is $v$ quantified over?]}
\Sewon{[$v$ is the possible values of the function call;
hence, should be universally quantified in the previous sentence:
for all $v\;x$, $f(x)$ is defined to be $v$ if and only if
one of the domain predicates holds on $x$ and $x,v$ satisfies $\phi(x)\to\psi(v,x)$.
If $f$ were a multifunction we could say, instead, 
$f(x)$ is proper (doesn't contain $\bot$) and contains $v$, if and only if $\cdots$.
I think you don't like `if and only if' part; since specification of a program is usually looser than 
what the program really does. But I think without referring one concrete definition (or specification) of a function, 
we cannot prove anything:
if the provided specification says $f$ is defined when $x>0$, then the prover should think $f(x) = \bot$ when
$x \leq 0$. When the provided specification says $x>0 \to v<0$, then the prover should think 
$f(x)$ to be any value less than $0$ but cannot be any nonnegative value.
]
}
The requirement is essential especially since we do not have a multivalued object in our assertion language.
Consider we have a symbol representing an integer valued multi--function $g$.
However, we cannot write $g(x)$ in our assertion language.
The purpose is to write $\{\omega : P(\omega)\}$ instead, where $P$ would be some predicate
in our language.
Whereas, for real valued single function, we leave the function symbol $f$ in our assertion language.
$\phi(f)_i$ will be used to check its domain and $\psi(f)_i$  will be 
loaded to the theory of our assertion system.

For examples, suppose we have a function symbol
$\texttt{soft} :\dint \times \dreal \times \dreal \to \dint$ in $\mathcal{F}$. 
Then, there will be pairs of predicates $(x < y + 2^{p}, \texttt{soft}(p,x,y) =1)$
and $(y < x + 2^{p}, \texttt{soft}(p,x,y) =0)$. 
In our assertion language, 
when we wish express the values of the term $\texttt{soft}(x,y,z)$,
we cannot refer to $\texttt{soft}$;
 instead, 
we write $\lambda \omega.\; (x<y+2^{p}\lor y<x+2^{p}) \land x<y+2^{p} \to \omega = 1 \land y<x+2^{p} \to \omega = 0$

On the other hand, consider we have a function symbol 
 $\texttt{sqrt} : \dreal \to \dreal$ in $\mathcal{G}$. Then, 
there will be a pair of predicates $(x>0, \texttt{sqrt}(x) \times \texttt{sqrt}(x) = x)$.
In this case, since $\texttt{sqrt}$ is only a single--valued \Martin{[No!]} 
\Sewon{[But $\mathcal{F}$ only includes single--valued function?
also, I want to keep function symbols as long as they're single--valued; 
because, then, we can say the Trisection program computes a root of the $f$]} 
function, we keep the symbol 
$\texttt{sqrt}$ in our system with $x>0 \to \texttt{sqrt}(x) \times \texttt{sqrt}(x) = x$
being an element of our theory.

\subsection{Translation Function}
In a simple language, it is trivial how to translate a programming term into an assertion language;
for an example, consider a programming term $x>y$ where $x, y$ are variables. 
Then, the corresponding predicate which defines the set of states which yields the
evaluation (semantic) of the term to be a boolean value \texttt{true} would be $x>y$.

However, in ERC, the semantic of terms is quite subtle. 
Since a term $t$ can be multivalued itself, the direct translation does not work:
\Martin{Its semantics is a \emph{set}. Now}
we do not have a power object in the assertion language.
Instead \Martin{we identify the set of values with the properties
of its elements, expressed as in first-order logic as predicate 
over the two-sorted structure of integers and real numbers.}
%of directly using the semantic defined in the previous section, 
We construct a translation function which 
translates a well--typed term into a predicate in our assertion language
which exactly defines the values of the term's semantic.

We introduce two translation functions that are constructed simultaneously.
$\transh{t}(k)\sigma$ defines those values in $\sem{t}\sigma$ except for $\bot$ and
$\trans{t}(k)\sigma$ defines those values in a proper $\sem{t}\sigma$ only; otherwise 
$\{v : \trans{t}(k)\sigma\}$. Hence, only $\trans{\cdot}$ function will be used in the 
assertion language. However, $\transh{\cdot}$ is required to construct the function:
think it as a helper function.

Translation function is also only for well--typed terms. However,
to ease writing, we write $\trans{t}$ instead of $\trans{\Gamma\vdash t : \tau}$;
when $\Gamma$ or $\tau$ appears, it refers to those that are omitted.
To be precise, $\trans{\Gamma\vdash t : \tau}$ is a predicate on $\sem{t}\times\sem{\Gamma}$.
For example, $\trans{\Gamma\vdash x : \dreal} = \lambda r.\lambda\sigma.\;r=\sigma(x)$.
However, to make the description simpler, we leave $\sigma(\cdot)$ implicit.
Hence, we will write
$\trans{\Gamma\vdash x : \dreal} = \lambda r.\;r=x$ instead. (Same for $\transh{\cdot}$)

\newpage
\begin{flalign*}
&\transh{c} = \lambda \omega.\; \omega  = c&\\
&\transh{  c.0  } = \lambda \omega.\; \omega  = c&\\
&\transh{  v  } = \lambda \omega.\; \omega  =  v &\\
&\transh{  T[z]  } = \lambda \omega.\; \exists n.\;\omega  = \pi_n (T) &\\
&\transh{  x > y  } = &\\
&\quad\lambda \omega.\; &\\
&\quad\quad\quad
\omega  = 1 \land \exists \omega _1\;\omega _2.\; \transh{x}(\omega _1) \land \transh{y}(\omega _2) \land \omega _1 > \omega _2 &\\
&\quad\quad
\lor \omega  = 0 \land \exists \omega _1\;\omega _2.\; \transh{x}(\omega _1)\land\transh{y}(\omega _2)\land \omega _2 < \omega _1&\\
% single valued real function
&\transh{  f(t_1, \cdots, t_n) : \dreal  } =&\\
&\quad \lambda \omega.\;&\\
&\quad\quad\quad
 \exists \omega _1 \cdots \omega _n.\; \omega  = f(\omega _1,\cdots,\omega _n)\land(\land_i \transh{t_i}(\omega _i))
\land \lor_i  (\phi(f)_i(\omega_1,\cdots,\omega_n)) &\\
% multivalued valued integer function
&\transh{  f(t_1, \cdots, t_n) : \dint  } =&\\
&\quad \lambda \omega.\;&\\
&\quad\quad\quad 
\exists \omega _1 \cdots \omega _n.\;
(\land_i \transh{t_i}(\omega _i)) 
\land(\land_i 
(\phi(f)_i \to\psi(f)_i)(\omega,\omega_1,\cdots,\omega_n)) \land \lor_i \phi(f)_i(\omega_1,\cdots,\omega_n) &\\
%arithmetics
&\transh{t_1 + t_2} = \lambda \omega.\; \exists \omega _1\;\omega _2.\;
\omega  = \omega _1+\omega _2\land \transh{t_1}(\omega _1) \land \transh{t_2}(\omega _2)&\\
&\transh{-t} = \lambda \omega.\; \exists \omega '.\; \omega  = -\omega '\land \transh{t}(\omega ')&\\
&\transh{  x * y } = \lambda \omega.\; 
\exists \omega _1\;\omega _2.\; \omega  = \omega _1\times \omega _2 \land \transh{t_1}(\omega _1)\land \transh{t_2}(\omega _2)&\\
&\transh{  /x  } = \lambda \omega.\; 
\exists \omega '\neq0.\; \omega  \times \omega ' = 1\land \transh{x}(\omega ')  &\\
&\transh{  \max(t_1, t_2)  } = \lambda \omega.\; \exists \omega _1\;\omega _2.\;
\omega  = \max(\omega _1,\omega _2)\land \transh{t_1}(\omega _1) \land \transh{t_2}(\omega _2)&\\
&\transh{  \neg z  } = \lambda \omega.\; 
(\omega  = 1 \land \transh{z}(0)) \lor (\omega  = 0 \land \exists \omega '\neq0.\; \transh{z}(\omega ')) &\\
% conjunction
&\transh{  z_1 \land z_2  } = &\\
&\quad
\lambda \omega.\;&\\
&\quad\quad\quad
\omega  = 0 \land 
( \transh{z_1}(0) \lor \transh{z_2}(0)) &\\
&\quad\quad
\lor
\omega  = 1 \land \exists \omega _1\;\omega _2.\;(\omega _1,\omega _2\neq 0\land\transh{z_1}(\omega _1) \land \transh{z_2}(\omega _2)) &\\
% disjunction
&\transh{  z_1 \lor z_2  } = &\\
&\quad\lambda \omega.\; &\\
&\quad\quad\quad
\omega  = 1 \land \exists \omega _1\;\omega _2 \neq0.\;
 \transh{z_1}(\omega _1)\lor\transh{z_2}(\omega _2)) &\\
&\quad\quad
\lor
\omega  = 0 \land (\transh{z_1}(0) \land \transh{z_2}(0)) &\\
%select
&\transh{  \select(z_0,z_1)  } = \lambda \omega.\;
(\omega = 0  \land \exists \omega_0.\; \transh{z_0}(\omega _0))
\lor
(\omega = 1  \land \exists \omega_1.\; \transh{z_1}(\omega _1))
&\\
% inline conditional
&\transh{  z\;?\;x:y  } = &\\
&\quad\lambda \omega.&\\  
&\quad\quad
\exists \omega_1\neq0 \; \omega_2.\; \omega=\omega_2 \land \transh{z}(\omega_1) \land \transh{x}(\omega_2) &\\
&\quad\quad
\lor\exists \omega_3.\; \omega = \omega_3 \land \transh{z}(0) \land \transh{y}(\omega_3) &\\
&\quad\quad
\lor\neg (\exists \omega_1.\;\trans{z}(\omega_1)) \land \exists \omega_1.\;\omega=\omega_1 \land \trans{x}(\omega_1)\land \trans{y}(\omega_1) 
&\\
&
\quad\quad\quad\quad\quad\quad\quad\quad
\quad\quad\quad\quad\quad\quad\quad\quad\land
\forall \omega_2.\; \trans{x}(\omega_2) \lor \trans{y}(\omega_2) \to \omega_1 = \omega_2 &\\
\end{flalign*}

\begin{flalign*}
&\transh{  \iota(z)  } = \lambda \omega.\;  
\exists \omega '.\; \omega  = 2^{\omega '}\land\transh{z}(\omega ')&\\
\end{flalign*}
\begin{flalign*}
&\trans{c} = \lambda \omega.\; \omega  = c&\\
&\trans{  c.0  } = \lambda \omega.\; \omega  = c&\\
&\trans{  v  } = \lambda \omega.\; \omega  =  v &\\
&\trans{  T[z]  } = \lambda \omega.\; (\exists n.\;\omega  = \pi_n (T) \land \trans{z}(n)) \land (\forall n.\; \trans{  z  }(n) \to 0\leq n <  \dim(T)) &\\
&\trans{  x > y  } = &\\
&\quad\lambda \omega.\; &\\
&\quad\quad\quad
\omega  = 1 \land \exists \omega _1\;\omega _2.\; \trans{x}(\omega _1) \land \trans{y}(\omega _2) \land \omega _1 > \omega _2 &\\
&\quad\quad
\lor \omega  = 0 \land \exists \omega _1\;\omega _2.\; \trans{x}(\omega _1)\land\trans{y}(\omega _2)\land \omega _2 < \omega _1&\\
&\quad\quad
\land \forall \omega _1\;\omega _2.\; \trans{x}(\omega _1)\land\trans{y}(\omega _2) \to \omega _1 \neq \omega _2&\\
% single valued real function
&\trans{  f(t_1, \cdots, t_n) : \dreal  } =&\\
&\quad \lambda \omega.\;&\\
&\quad\quad\quad
 \exists \omega _1 \cdots \omega _n.\; \omega  = f(\omega _1,\cdots,\omega _n)\land(\land_i \trans{t_i}(\omega _i)) &\\
&\quad\quad
\land\forall \omega _1 \cdots \omega _n.\; (\land_i \trans{t_i}(\omega_i))
\to \lor_i \phi(f)_i(\omega_1,\cdots,\omega_n) &\\
% multivalued valued integer function
&\trans{  f(t_1, \cdots, t_n) : \dint  } =&\\
&\quad \lambda \omega.\;&\\
&\quad\quad\quad 
\exists \omega _1 \cdots \omega _n.\;
(\land_i \trans{t_i}(\omega _i)) 
\land(\land_i 
(\phi(f)_i \to\psi(f)_i)(\omega,\omega_1,\cdots,\omega_n)) &\\
&\quad\quad
\land\forall \omega _1 \cdots \omega _n.\; (\land_i \trans{t_i}(\omega_i))
\to \lor_i \phi(f)_i(\omega_1,\cdots,\omega_n) &\\
%arithmetics
&\trans{t_1 + t_2} = \lambda \omega.\; \exists \omega _1\;\omega _2.\;
\omega  = \omega _1+\omega _2\land \trans{t_1}(\omega _1) \land \trans{t_2}(\omega _2)&\\
&\trans{-t} = \lambda \omega.\; \exists \omega '.\; \omega  = -\omega '\land \trans{t}(\omega ')&\\
&\trans{  x * y } = \lambda \omega.\; 
\exists \omega _1\;\omega _2.\; \omega  = \omega _1\times \omega _2 \land \trans{t_1}(\omega _1)\land \trans{t_2}(\omega _2)&\\
&\trans{  /x  } = \lambda \omega.\; 
\exists \omega '\neq0.\; \omega  \times \omega ' = 1\land \trans{x}(\omega ') \land \forall \omega'.\;\trans{x}(\omega') \to \omega'\neq0&\\
&\trans{  \max(t_1, t_2)  } = \lambda \omega.\; \exists \omega _1\;\omega _2.\;
\omega  = \max(\omega _1,\omega _2)\land \trans{t_1}(\omega _1) \land \trans{t_2}(\omega _2)&\\
&\trans{  \neg z  } = \lambda \omega.\; 
(\omega  = 1 \land \trans{z}(0)) \lor (\omega  = 0 \land \exists \omega '\neq0.\; \trans{z}(\omega ')) &\\
% conjunction
&\trans{  z_1 \land z_2  } = &\\
&\quad
\lambda \omega.\;&\\
&\quad\quad\quad
\omega  = 0 \land 
( \trans{z_1}(0) \lor \trans{z_2}(0)) &\\
&\quad\quad\quad\quad\quad\enspace
\land \Big(\forall \omega _1.\;\trans{z_1}(\omega _1)\to \omega _1=0 \land
\forall \omega _2.\;\trans{z_2}(\omega _2) \to \omega _2 = 0&\\
&\quad\quad\quad\quad\quad\enspace\quad\quad
\lor \exists  \omega _1\;\omega _2.\; \trans{z_1}(\omega _1)\land\trans{z_2}(\omega _2)\Big) &\\
&\quad\quad
\lor
\omega  = 1 \land \exists \omega _1\;\omega _2.\;(\omega _1,\omega _2\neq 0\land\trans{z_1}(\omega _1) \land \trans{z_2}(\omega _2)) &\\
\end{flalign*}
\begin{flalign*}
% disjunction
&\trans{  z_1 \lor z_2  } = &\\
&\quad\lambda \omega.\; &\\
&\quad\quad\quad
\omega  = 1 \land \exists \omega _1\;\omega _2.\;
(\omega _1, \omega _2 \neq 0 \land \trans{z_1}(\omega _1) \lor \trans{z_2}(\omega _2)) &\\
&\quad\quad\quad\quad\quad\enspace
\land \Big(\forall \omega _1.\;\trans{z_1}(\omega _1)\to \omega _1 \neq 0 \land
\forall \omega _2.\;\trans{z_2}(\omega _2)\to \omega _2 \neq 0 &\\
&\quad\quad\quad\quad\quad\enspace\quad\quad
\lor \exists  \omega _1\;\omega _2.\; \trans{z_1}(\omega _1)\land\trans{z_2}(\omega _2)\Big) &\\
&\quad\quad
\lor
\omega  = 0 \land (\trans{z_1}(0) \land \trans{z_2}(0)) &\\
%select
&\trans{  \select(z_0,z_1)  } =&\\
&\quad\lambda \omega.\;&\\
&\quad\quad(\omega = 0  \land \exists \omega_0.\; \transh{z_0}(\omega _0))
\lor
(\omega = 1  \land \exists \omega_1.\; \transh{z_1}(\omega _1)) \\
&\quad\quad\land 
\exists k.\; \trans{z_0}(k) \lor \trans{z_1}(k)
&\\
% inline conditional
&\trans{  z\;?\;x:y  } = &\\
&\quad\lambda \omega.&\\  
&\quad\quad
\exists \omega_1\neq0.\; \trans{z}(\omega_1) \to \exists \omega_2.\; \trans{x}(\omega_2)  &\\
&\quad\quad
\land\trans{z}(0) \to \exists \omega_3.\; \trans{y}(\omega_3) &\\
&\quad\quad
\land\quad\exists \omega_1\neq0 \; \omega_2.\; \omega=\omega_2 \land \trans{z}(\omega_1) \land \trans{x}(\omega_2) &\\
&\quad\quad\quad
\lor\exists \omega_3.\; \omega = \omega_3 \land \trans{z}(0) \land \trans{y}(\omega_3) &\\
&\quad\quad\quad
\lor\neg (\exists \omega_1.\;\trans{z}(\omega_1)) \land \exists \omega_1.\;\omega=\omega_1 \land \trans{x}(\omega_1)\land \trans{y}(\omega_1) 
&\\
&
\quad\quad\quad\quad\quad\quad\quad\quad
\quad\quad\quad\quad\quad\quad\quad\quad\land
\forall \omega_2.\; \trans{x}(\omega_2) \lor \trans{y}(\omega_2) \to \omega_1 = \omega_2 &\\
&\trans{  \iota(z)  } = \lambda \omega.\;  
\exists \omega '.\; \omega  = 2^{\omega '}\land\trans{z}(\omega ')
\end{flalign*}

\begin{theorem}
\label{t:Defined}
$\{v : \transh{\Gamma\vdash t : \tau}(v)\sigma\} = \sem{\Gamma\vdash t : \tau}\sigma\setminus\{\bot\}$. And,
$\{v : \trans{\Gamma\vdash t : \tau}(v)\sigma\} = \varnothing$ if and only if $\bot\in\sem{\Gamma\vdash t : \tau}\sigma$.
If $\{v : \trans{\Gamma\vdash t : \tau}(v)\sigma\} \neq \varnothing$, then
it coincides with $\sem{\Gamma\vdash t : \tau}\sigma$
\end{theorem}
\begin{proof}
It can be proved with induction on $t$.
Skipping the trivial cases, let us see $\transh{z\;?\;x:y}$, $\trans{x>y}$, and $\trans{\select(z_0,z_2)}$.

\vspace{0.5em}
\noindent
-- [\textit{conditional}]\quad
Induction hypothesis says $\transh{z}(\omega_1) \leftrightarrow \omega_1\in\sem{z}$,
$\transh{x}(\omega_2) \leftrightarrow \omega_2 \in \sem{x}$ and
$\transh{z}(\omega_3) \leftrightarrow \omega_3 \in \sem{z}$
for all $\omega_{1,2,3}$.
See that $\transh{z\;?\;x:y}(\omega)$ if and only if either
\begin{enumerate}
\item
$\exists \omega_1\neq0.\; \transh{z}(\omega_1)\land\transh{x}(\omega) $
\item
$\transh{z}(0) \land \transh{y}(\omega)$
\item
$\neg (\exists \omega'.\;\trans{z}(\omega'))  \land \trans{x}(\omega)\land \trans{y}(\omega) 
\land \forall \omega'.\; \trans{x}(\omega') \lor \trans{y}(\omega') \to \omega' = \omega$
\end{enumerate}
Consider the last case:
 $\neg (\exists \omega'.\;\trans{z}(\omega'))$ if and only if $\bot\in\sem{z}\sigma$.
$\trans{x}(\omega)\land \trans{y}(\omega) 
\land \forall \omega'.\; \trans{x}(\omega') \lor \trans{y}(\omega') \to \omega' = \omega$ if and only if
$\sem{x}\sigma=\sem{y}\sigma = \{\omega\}$; hence, $\omega\in\sem{z\;?\;x:y}\sigma$.
Hence the above three conditions are equivalent to:
\begin{enumerate}
\item
$\exists \omega_1\neq0.\; \omega_1\in\sem{z}\sigma \land \omega\in\sem{x}\sigma $
\item
$0\in\sem{z}\sigma \land \omega\in\sem{y}$
\item
$\bot\in\sem{z}\sigma \land \sem{x}\sigma=\sem{y}\sigma=\{\omega\}$
\end{enumerate}
Hence, $\transh{z\;?\;x:y}(\omega)$ if and only if $\omega \in\sem{z\;?\;x:y}\sigma$

\vspace{0.5em}
\noindent
-- [\textit{real comparison}]\quad
See that $\bot\in\sem{x>y}\sigma$ if and only if either $\bot\in\sem{x}\sigma$ or $\bot\in\sem{y}\sigma$ or $\exists z.\;z\in\sem{x}\sigma\land z\in\sem{y}\sigma$. If either $\bot\in\sem{x}\sigma$ or $\bot\in\sem{y}\sigma$, by the induction hypothesis,
$\{v:\trans{x}(v)\} =\varnothing$ or $\{v : \trans{y}(v)\} = \varnothing$. Either case $\{v : \trans{x>y}(v)\} = \varnothing$.
Suppose $\exists z.\; z\in\sem{x}\land z\in\sem{y}$. Then the last clause, $z\neq z$ cannot be satisfied. Hence, $\{v : \trans{x>y}(v)\} = \varnothing$.

If $\{v : \trans{x>y}(v)\} = \varnothing$, using tautological equivalence yields two cases:
$\exists \omega_1\;\omega_2.\; \trans{T}(x)\land\trans{T}(y)\land x=y$
or
$\forall v.\; \trans{x}(v) \lor \trans{y}(v)$. By the induction hypothesis, $\exists z.\; z\in\sem{x}\sigma \land z \in \sem{y}\sigma$ or $\bot\in\sem{x}\sigma \lor \bot\in\sem{y}\sigma$. Hence, $\bot\in\sem{x>y}\sigma$.

Suppose $\trans{x>y}(0)$ Since $\trans{x>y}(0) \to \exists \omega_1\;\omega_2.\; \trans{x}(\omega_1) \land\trans{y}\omega_2)\land \omega_2<\omega_1$, by the induction hypothesis, we have $\exists \omega_1\;\omega_2.\;\in\sem{x}\sigma \land \sem{y}\sigma\land \omega_2<\omega_1$. Hence, $1\in\sem{x>y}\sigma$. The other case can be done similarly. 

See that $1\in\sem{x>y}\sigma$ if and only if $\exists x'\;y'.\; x'\in\sem{x}\sigma\land y'\in\sem{y}\sigma \land x'>y'$. Hence, by induction hypothesis, 
$\exists \omega_1\;\omega_2.\; \trans{x}(\omega_1)\land \trans{y}(\omega_2)\land \omega_1>\omega_2$. 
Hence, $\trans{x>y}(1)$ holds. The other case can be done similarly.

%\vspace{0.5em}
%\noindent
%[\textit{conjunction}]\quad
%See that $\bot\in\sem{z_1\land z_2}\sigma$ if and only if either $\bot\in\sem{z_1}\land 0\neq k\in\sem{z_2}$ or $0\neq k\in\sem{z_1}\land\bot\in\sem{z_2}\sigma$ or $\bot\in\sem{z_1}\sigma\land\bot\in\sem{z_2}\sigma$.
%If $\bot\in\sem{z_1}\sigma\land\bot\in\sem{z_2}\sigma$, by induction hypothesis, $\trans{z_1}(\omega) \equiv \trans{z_2}(\omega)
%\equiv false$ for any $\omega$. Hence, $\trans{z_1\land z_2}(\omega) \equiv false$.
%If $\bot\in\sem{z_1}\land 0\neq k\in\sem{z_2}$ and $0\not\in\sem{z_2}$, by the induction hypothesis, 
%$\trans{z_1}(0) \lor \trans{z_2}(0) \equiv false$ and $\trans{z_1}(\omega) \equiv false$ for any $\omega$. 
%Hence, $\trans{z_1\land z_2}(\omega) = false$ for any $\omega$.
%If $0\in\sem{z_2}$, $\trans{z_1}(0)\lor\trans{z_2}(0) \equiv true$. However, $\forall \omega_2.\; \trans{z_2}(\omega_2) \to \omega_2 = 0 \equiv false$ and $\exists \omega_1.\; \trans{z_1}(\omega_1) \equiv false$. Hence $\trans{z_1\land z_2}(\omega) = false$ for any $\omega$. The other case can be done similarly.


\vspace{0.5em}
\noindent
-- [\textit{select}]\quad
$\bot\in\sem{\select(z_0, z_1)}\sigma$ if and only if $\bot\in\sem{z_0}\sigma\land \bot\in\sem{z_1}\sigma$.
Then, by the induction hypothesis, $\{v : \trans{z_0}(v)\} = \{v : \trans{z_1}(v)\} = \varnothing$.
Then, $\exists \omega '.\; \omega  = 2^{\omega '}\land\trans{z}(\omega ')$ 
cannot be satisfied, hence, $\{v : \trans{\select(z_0, z_1)}(v)\} = \varnothing$.

If $\{v : \trans{\select(z_0, z_1)}(v)\} = \varnothing$, then 
$\{v : \trans{z_0}(v)\} = \{v : \trans{z_1}(v)\} = \varnothing$. Hence, $\bot\in\sem{z_0}\sigma\land \bot\in\sem{z_1}\sigma$
and $\bot\in\sem{\select(z_0, z_1)}\sigma$.

$\bot\not\in \sem{\select(z_0, z_1)}\sigma$ and $1\in\sem{\select(z_0, z_1)}\sigma$ 
if and only if $\exists k.\; \trans{z_0}(k) \lor \trans{z_1}(k)$ and $\sem{z_1}\sigma \neq \{\bot\}$ includes some 
non bottom element. 
Hence, $\exists k.\;\transh{z_1}(k)$; therefore, $\trans{\select(z_0, z_1)}(1)$. 

Suppose $\trans{\select(z_0, z_1)}(1)$. Then, $\transh{z_1}(1)$ hence, $\exists k\neq\bot.\; k\in\sem{z_1}\sigma$. 
Therefore, $1\in \sem{\select(z_0, z_1)}\sigma$.
The same can be done for the case $0$.



\noindent
[\textit{conditional}]\quad

\end{proof}

\subsection{Hoare Logic}


Hoare triple of a well--typed statement is defined as follow:
\[
\asser{P}\;\Gamma\vdash S \triangleright \Gamma' \asser{Q}
\]
where $P$ is a predicate on $\sem{\Gamma}$ and $Q$ is a predicate on $\sem{\Gamma'}$.
The Hoare triple is a proposition saying that for all state satisfying $P$, execution (semantic) of $S$ yields 
a proper set of states which each element satisfies $Q$:
\begin{flalign}
\label{eq:hoaremeaning}
&\asser{P}\;\Gamma\vdash S \triangleright \Gamma' \asser{Q} := &\\
&\quad\quad\forall \sigma. P\;\sigma \to (\bot\not\in
\sem{\Gamma \vdash S \triangleright \Gamma'}\sigma \land
\forall \delta \in \sem{\Gamma \vdash S \triangleright \Gamma'}\sigma.\; Q\;\delta) &\nonumber
\end{flalign}
\Martin{[What is $\sem{\Gamma \vdash S \triangleright \Gamma'}$ ?]}
\Sewon{[Its the semantic of a well--typed statement; see Section \ref{ss:semstatement}]}
The following inference rules can be introduced:
\begin{mathpar}
% empty
\infer{\asser{P}\Gamma \vdash \epsilon  \triangleright \Gamma\asser{P}}{%
}
\and
% variable assignment
\infer{\asser{
\exists w.\;\trans{t}(w)\land
\forall w.\; \trans{t}(w)\to P[v\mapsto w]}\Gamma \vdash v:=t\; \triangleright \Gamma\asser{P}}{%
}
\and
%array assignment
\AxiomC{
}
\UnaryInfC{
\parbox{1\textwidth}{\centering
$
\asser{\exists w\;n.\;\trans{t}(w)\land\trans{z}(n)\land
\forall n.\;\trans{z}(n)\to 0\leq n<d\land
\forall w \;n.\; \trans{t}(w)\land\trans{z}(n) \to P[T\twoheadrightarrow_n w]}$
$
\Gamma \vdash T[z]:=t\; \triangleright \Gamma\asser{P}$}
}
\DisplayProof
\and
% new variable
\infer{\asser{
\exists w.\;\trans{t}(w)\land
\forall w.\; \trans{t}(w)\to P[v\mapsto w]}\Gamma \vdash \textbf{newvar}\;v:=t\; \triangleright \Gamma'\asser{P}}{%
}
\and
% Sequence
\infer{\asser{P} \Gamma \vdash S_1;S_2 \triangleright \Gamma_2\asser{R} }{%
\asser{P}\Gamma \vdash S_1 \triangleright \Gamma_1\asser{Q} &
\asser{Q}\Gamma_1 \vdash S_2 \triangleright \Gamma_2 \asser{R}
}
\and
% Conditional
\infer{
\asser{P \land \exists k.\; \trans{z}(k)}
\Gamma \vdash \textbf{if}\;z\;\textbf{then}\;S_1 \;\textbf{else}\;S_2 \triangleright \Gamma
\asser{Q}}{%
\asser{P\land\exists b\neq0.\; \trans{z}(b)} \Gamma \vdash S_1 \triangleright \Gamma \asser{Q}&
\asser{P\land \trans{z}(0)} \Gamma \vdash S_1 \triangleright \Gamma \asser{Q}
}
\and
% while loop
\AxiomC{
\parbox{\textwidth}{\centering $\exists c_0\forall c\asser{\exists k\neq0. \trans{z}(k) \land I\land V = c} \Gamma \vdash S \triangleright \Gamma\asser{I\land V \leq c - c_0}$ \newline
$I \to \exists k. \trans{z}(k) \quad 
I\land V \leq0\to\forall k.\;\trans{z}(k)\to k=0$}
}
\UnaryInfC{$\asser{I}\Gamma \vdash \textbf{while}\;z\;\textbf{do}\;S  \triangleright \Gamma\asser{I \land h(z)(0)}$}
\DisplayProof
\and
% 
\infer{\asser{P}\Gamma \vdash S  \triangleright \Gamma'\asser{Q}}{%
P \to P'
\asser{P'}\Gamma \vdash S  \triangleright \Gamma'\asser{Q'} &
Q' \to Q
}
\end{mathpar}

\Martin{[Let us also add rules about function calls to 
integer multifunction $g\in\mathcal{G}$ and real function $f\in\mathcal{F}$
with specification according to the beginning of Section~4 here
and Definition~7 in the main text.]}
\Sewon{[function call is a term constructor hence doesn't belong here;
Hoare triple says how a statement changes states.
Function call should be dealt in the semantic of terms section.
]}

\begin{theorem}\label{t:hoaresound}
The introduced inference rules are sound; for each inference rule, Equation \ref{eq:hoaremeaning} 
is satisfied.
\end{theorem}
\begin{proof}
It can be proved using induction on statements.
The other proofs are trivial except for the conditional and loop statements.

\vspace{.5em}
\noindent[\textit{conditional}]
The precondition $(P\land \exists k.\;\trans{z}(k))\;\sigma$ ensures $\bot\not\in\sem{z}\sigma$ finite.
If $\exists k\neq0.\; \{0,k\} \subseteq \sem{z}\sigma$, then 
$\sem{\textbf{if}\;\cdots}\sigma = \sem{S_1}\sigma \cup \sem{S_2}\sigma$.
If $\exists k\neq0.\;\{0,k\} \subseteq \sem{z}\sigma$,
then $\exists k\neq0.\;\trans{z}(k)$ and $\trans{z}(0)$.
By the premises, for all $\delta\in\sem{S_1}\sigma\cup\sem{S_2}\sigma$, 
and the case distinction, $Q(\delta)$ holds. For the cases $0\not\in \sem{z}\sigma$ and
$\{0\}=\sem{z}\sigma$, can be done similarly.
 
 \vspace{.5em}
 \noindent[\textit{loop}] The loop variant $V$ can be replaced to an original integer version
 $V' := \lceil V/c_0\rceil$:
\begin{align*}
&\forall c\asser{\exists k\neq0. \trans{z}(k) \land I\land V' = c} \Gamma \vdash S \triangleright \Gamma\asser{I\land V' < c}\\
&I\land V' \leq0\to(\forall k.\;\trans{z}(k)\to k=0)
\end{align*}
Also, the real loop variant can be restored from any loop invariant; hence, let us consider the integer loop variant.
 
 
Recall the chain $\omega_0\sqsubseteq\omega_1\sqsubseteq \cdots$ where
$\sem{\Gamma \vdash \textbf{while}\;z\;\textbf{do}\;S \triangleright \Gamma'} = \bigsqcup_\infty \omega_i$.
We need to prove that for any $\sigma$ with the precondition $I(\sigma)$ the following holds:
\[
\bot \not \in (\sqcup_\infty \omega_i)\sigma \land \forall \delta \in 
(\sqcup_\infty \omega_i)\sigma.\;(I\land h(z)(0))\delta
\]
Point--wise ordering on $\sem{\Gamma}\to\mathcal{P}\sem{\Gamma}_\bot$
ensures that $\omega_1\sigma \sqsubseteq \omega_2\sigma \sqsubseteq \cdots$ is a chain;
hence, $(\bigsqcup_\infty \omega_i)\sigma = \bigsqcup_\infty (\omega_i \sigma)$.
Due to the ordering on $\mathcal{P}\sem{\Gamma}_\bot$,
$\bot\not\in \bigsqcup_\infty (\omega_i\sigma)$ if and only if
there is some $n$ such that $\bot \not \in \omega_n\sigma$ finite and
$\omega_{n} \sigma = \omega_{n+1} \sigma =\cdots$.
The loop variant will 
yield the bound; we need to prove the following:
\begin{align}
\label{eq:hoarelooppf}
\forall \sigma\;c.\;I \;\sigma\land V'\;\sigma\leq c \to 
\bot \not \in \omega_{c+1}\sigma \land \forall \delta \in 
\omega_{c+1}\sigma.\;(I\land h(z)(0))\delta
\end{align}
If $c=0$, due to the premises, $\forall k.\;\trans{z}(k)\sigma \to k=0$ and $I\;\sigma$ ensures $\exists k.\;\trans{z}(k)\sigma$.
Therefore, $\sem{z}\sigma =\{0\}$.
Hence, $\omega_1(\sigma) =  \{\sigma\}$ and $\bigsqcup_\infty(\omega_j \sigma) = \{\sigma\}$.

\vspace{1em}

Now, let us assume Equation \ref{eq:hoarelooppf} and prove
the following proposition:
\[ 
\bot \not \in \omega_{c+2}\sigma \land \forall \delta \in 
\omega_{c+2}\sigma.\;(I\land h(z)(0))\delta
\]
assuming $I\;\sigma\land V'\;\sigma\leq c+1$ for some $\sigma$. Due to the premises, we have $\bot\not\in\sem{z}\sigma$ finite.
Let us consider the case $\{0,k\}\subseteq\sem{z}\sigma$ for some nonzero $k$.
The premise about the loop body ensures the following (with $c := c+1$):
\[
\bot\not\in\sem{S}\sigma\land
\forall \delta \in \sem{S}\sigma.\; (I\land V\leq c)\delta
\]
Since, $\bot\not\in\sem{S}\sigma$ finite, using $\omega_{c+2}:=\mathcal{F}_{z,\;S}\omega_{c+1}$, we have the following:
\[
\omega_{c+2} = \{\sigma\}\cup\bigcup_{\delta \in \sem{S}\sigma} \omega_{c+1}\delta
\]
Using the induction hypothesis on any $\delta\in\sem{S}\sigma$, we have
\[
\bot\not\in \omega_{c+1}\delta \land \forall \delta' \in \omega_{c+1}.\; (I\land h(z)(0))\delta'
\]
Hence, $\bot\not\in\omega_{c+2}\sigma$ finite and all its element, including $\sigma$, satisfies $I\land h(z)(0)$.

The case $0\not\in\sem{z}\sigma$ can be done similarly and the other case $\{0\}=\sem{z}\sigma$ can be
done exactly as the case $c=0$.
\end{proof}

\subsection{Verification Condition}
Verification condition of a well--typed statement $\Gamma \vdash S \triangleright \Gamma'$ annotated with
a predicates $Q : Pred(\sem{\Gamma'})$ is a predicate $vc(\Gamma \vdash S \triangleright \Gamma', Q) : Pred(\sem{\Gamma})$,
which defines a set of states such that 
\[
\forall \sigma \in \sem{\Gamma}.\; vc(\Gamma \vdash S \triangleright \Gamma',Q) (\sigma)
\rightarrow
\bot\not\in\sem{S}\sigma \land \forall \delta \in \sem{S}\sigma.\; Q(\delta).
\]
Verification condition is defined inductively as follow:
\begin{flalign*}
% empty
&vc(\epsilon, Q) = Q &\\
% variable assignment
&vc(v := t, Q) = \exists w.\;\trans{t}(w)\land \forall w.\; \trans{t}(w) \to Q[v\mapsto w]&\\
% array assignment
&vc(T[z] := t, Q) =
(\exists n\;w.\;\trans{z}(n)\land\trans{t}(w))\land&\\
&\qquad\qquad\qquad\qquad
\land(\forall n.\;\trans{z}(n)\to 0\leq n < d)&\\
&\qquad\qquad\qquad\qquad
\land(\forall n\;w.\; \trans{z}(n)\land\trans{t}(w) \to Q[T \mapsto T\twoheadrightarrow_n w])&\\
% variable declaration
&vc(\textbf{newvar}\;v := t, Q) =  \exists w.\; \trans{t}(w) \land \forall w.\; \trans{t}(w) \to Q[T\mapsto w]&\\
% sequence
&vc(S_1; S_2, Q) = vc(S_1, wp(S_2, Q))&\\
% conditional
&vc(\textbf{if}\;z\;\textbf{then}\; S_1 \; \textbf{else}\; S_2, Q) =&\\
&\qquad\qquad\exists k. \trans{z}(k) \land
(\exists k\neq0.\; \trans{z}(k) \to vc(S_1, Q))\land
(\trans{z}(0) \to vc(S_2, Q))&\\
% loop
&vc(\textbf{while}\;z\;\textbf{do}\; S, Q) = &\\
&\qquad\qquad I \land &\\
&\qquad\qquad\forall\;\mathbf{v}.\;&\\
&\qquad\qquad\quad\quad(I \land \trans{z}(0) \to Q)  &\\
&\qquad\qquad\quad\land I \to (\exists k. \trans{z}(k))  &\\
&\qquad\qquad\quad\land\exists c_0. \forall c.\; (I \land (\exists k\neq0.\; \trans{z}(k)) \land (V = c) \to vc(S, I \land V \leq c - c_0))&\\
&\qquad\qquad\quad\land V \leq 0 \to (\forall v.\;\trans{z}(v) \to v=0)
\end{flalign*}
Above $\mathbf{v}$ represents the set of variables that gets assigned in $S$.
the first clause $I$ denotes that the loop invariant $I$ should hold at the beginning of the loop;
other clauses are conditions that should be satisfied throughout any stages of the loop.


\begin{theorem}
The introduced verification condition is correct
\end{theorem}
\begin{proof}
The definition is induced from Hoare logic inference rules; hence, the proof is analogous to the proof of Theorem \ref{t:hoaresound}.
\end{proof}
Having a well--typed statement $S$, proving $P \to vc(S, Q)$ yields $\asser{P}\;S\;\asser{Q}$.
Note that the other way wont hold as $vc$ is not the weakest precondition.

\subsection{Program Verification}
Recall that a ERC program is in the following format:

\begin{flalign*}
&\prog := &\\
&\qquad\textbf{input}\;v_1 : \tau_1, v_2 : \tau_, \cdots, v_n : \tau_n &\\
&\qquad S &\\
&\qquad\textbf{return}\;t& 
\end{flalign*}

Considering that the program $\prog$ is well--typed, we have 
$\Gamma_0 \vdash S \triangleright \Gamma$ and $\Gamma \vdash t : \tau$
where $\Gamma_0 = \cup_i (v_i \to \tau_i)$ with some $\tau$.

Precondition of a program is a predicate that defines a set of input values of the input variables.
Postcondition should be a predicate on the input values of the input variables and their return value.
Hence, $Pre : Pred(\sem{\Gamma_0})$ and $Post : Pred(\sem{\tau}\times\sem{\Gamma_0})$.

Now, let us consider which predicate should hold at the end of the statement 
in order to guarantee $Post$.
One thing to make sure is that the semantic of the returning term to be proper and all of its elements to satisfy $Post$:
\[\exists r.\;\trans{t}(r)\land \forall r,\;\trans{t}(r)\to Post(r,\cdots)\]
However, the above modification is wrong since the
variables in the postcondition should refer to the initial values of the input variables,
not the values that the input variables are storing at the moment.

To make sure the variables in $Post$ refer to the initial values, we can alter the variables:
\[\exists r.\;\trans{t}(r)\land \forall r,\;\trans{t}(r)\to Post[v_i \mapsto v_i'](r)\]
We can compute the verification condition on the above predicate.
Since $v_i'$ refers to the initial values and the variables $v_i$ in $uv(\cot)$, now, also refer the the initial values, 
we can reset those altered variable back;
program verification of the program $\prog$ is to prove the following:
\begin{flalign*}
&pv(P,\prog,Q) :=&\\
&\quad\quad P \to vc(S, \exists r.\;\trans{t}(r)\land \forall r,\;\trans{t}(r)\to Q(r)[v_i\mapsto v_i'])[v_i'\mapsto v_i]&
\end{flalign*}
%\begin{theorem}
%For a program $\prog$ annotated with pre and postcondition $P$ and $Q$, 
%if $pv(P, \prog,Q)$ holds then,
%\[
%\forall\;\sigma.\;P\;\sigma \to \bot\not\in\sem{\prog}\sigma\land \forall v\in\sem{\prog}\sigma.\;Q\;v\;\delta
%\]
%\end{theorem}

\section{Example: Trisection}
Trisection, which is also introduced in the main text, is a rigorous algorithm
finding the root in the unit interval of a continuous function
where it is guaranteed that the function $f$ is (i) continuous, (ii) has a sign change
$f(0)<0<f(1)$ and (iii) its root is unique.

Since, we do not have a function typed variable in the language, 
we put the function in our set of the special function symbols.
Hence, we let $\mathcal{F} := \{f \mapsto \dreal\}$.
We put the three conditions into our theory. 

Trisection algorithm can be expressed as a program in ERC as follow:

\begin{flalign*}
&\textbf{Input}(n : \dint)&\\
&\quad\textbf{newvar}\; a :=0.0;&\\
&\quad\textbf{newvar}\; b :=1.0;&\\
&\quad\textbf{while}\; \select(\test{\iota(n) > b - a}, \test{b - a > \iota(n-1)}) &\\
&\quad\textbf{do}&\\
&\quad\quad \textbf{if}\; \select(f((a+2.0*b)*/3.0)>0.0, 0.0>f((2.0*a+b)*/3.0))&\\
&\quad\quad \textbf{then}\; a := (2.0*a+b)*/3.0)&\\
&\quad\quad \textbf{else}\; b:= (a+2.0*b)*/3.0&\\
&\textbf{return}\;a&
\end{flalign*}
It is not hard to see that the program is well--typed with its return type $\dreal$.


\subsection{Semantic of Terms}
\label{ss:semterm}
The current construction of the semantic translation function introduces many quantifiers.
As an example, even for a simple term like $(2.0*a+b)*/3.0$,
directly evaluating the translation yields the following long predicate:

\begin{align*}
&\trans{(2.0*a+b)*/3.0} =\\
&\lambda \omega.\; \\
&\qquad\exists v_1\; v_2. \;\omega =v_1  \times v_2  \land \\
&\qquad\qquad (\exists v_3 \; v_4.\; v_1 =v_3 + v_4 \land \\
&\qquad\qquad\qquad(\exists v_6 \; v_7.\; v_3=v_6  \times v_7  \land v_6 =2 \land v_7 =a \land v_4 =b \land \\
&\qquad\qquad\qquad\qquad(\exists v_5.\; 
1 = v_2  \times v_5  \land v_5 =3)))
\end{align*}

However, we can note that the quantifiers are trivial; 
we can reduce a predicate $\exists x.\; x=a\land b$
to $b[x\mapsto a]$. Hence, we can reduce most of quantifiers that are related to variables and constants;
since the introduced quantifiers are mostly related to multivaluedness and undefinedness.

Translated semantics of the terms in Trisection can be simplified as follow:

\begin{align*}
&\trans{0.0} =\\
&\qquad \lambda \omega.\; \omega = 0 \\
&\trans{1.0} = \\
&\qquad\lambda \omega.\; \omega = 1\\
&\trans{\select(\test{\iota(n) > b - a}, \test{b - a > \iota(n-1)})} = \\
&\qquad\lambda\omega.\; 
(\omega = 0\land 2^n > b - a) \lor (\omega = 1 \land b-a> 2^{n-1}) \\
&\trans{\select(f((a+2.0*b)*/3.0)>0.0, 0.0>f((2.0*a+b)*/3.0))} = \\
&\qquad\lambda\omega.\; 
\left(\omega=0\land f\left(\frac{a+2\cdot b}{3}\right) > 0\right) \lor
\left(\omega=1\land f\left(\frac{2\cdot a+ b}{3}\right) < 0\right) \\
&\trans{(2.0*a+b)*/3.0)} \\
&\qquad\lambda\omega.\; 
\omega = \frac{2\cdot a+b}{3}\\
&\trans{(a+2.0*b)*/3.0)} \\
&\qquad\lambda\omega.\; 
\omega = \frac{a+2\cdot b}{3}
\end{align*}

\subsection{Verification}
\label{ss:triverif}
We want the program to compute $2^{n}$ approximation of the root. 
Hence, we let our pre and postcondition to be as follow:
\begin{align*}
Pre &:= True, \\
Post &:= \lambda r.\;  \exists u.\; f(u) = 0< 0\leq u < 1 \land
approx(u,r,n).
\end{align*}
$Post$ is a predicate on the return value $r$ and the input value $n$.
$approx(u,r,n) := -2^n<r-u <2^n$ is an abbreviation.

Let the loop invariant to be $I := uniq(0, 1)$ and the loop variant to be 
$V = b-a-2^{n-1}$ where $uniq(a,b) := f(a)<0<f(b) \land 0< a<b< 1\land \exists!\;z.\; f(z) = 0\land a< z< b$.
Notice that $uniq(0,1)$ is the one of the conditions added to our theory.

With $Post$, the postcondition of the \textit{program}, we apply the verification condition function on 
the following predicate:
\begin{align*}
&Post':=\exists r.\;\trans{t}(r)\land \forall r,\;\trans{t}(r)\to Post[v_i \mapsto v_i'](r) \\
&\qquad\qquad=\exists r.\; r = a \land \forall r.\; r = a \to (\exists u.\;f(u)=0\land0\leq u \leq 1 \land |u - r|<2^{n'}) \\
&\qquad\qquad=(\exists u.\;f(u)=0\land0\leq u \leq 1 \land |u - a|<2^{n'})
\end{align*}

Abbreviating $S := \textbf{if} \cdots \textbf{then}\cdots \textbf{else}\cdots$ in the program, 
applying the verification condition function on the postcondition yields the following
five conditions to be proved:
\begin{align}
&uniq(0,1) \label{eq:init}\\
&\forall \alpha\;\beta.\nonumber\\
&\quad \big(uniq(\alpha,\beta) \land (2^n<\beta-\alpha) \to Post'[a\mapsto \alpha]\big)[n'\mapsto n] \label{eq:postinfer}\\
&\quad uniq(\alpha, \beta) \to  (2^n>\beta-\alpha \lor \beta-\alpha > 2^{n-1}) \label{eq:safety}\\
&\quad \exists c_0.\; \forall c.\;
uniq(\alpha,\beta) \land \beta-\alpha>2^{n-1} \land (\beta-\alpha-2^{n-1}) = c) 
\to \label{eq:invar}\\
\nonumber
&\quad \qquad\qquad vc(S, uniq(a,b)\land b-a\leq c - c_0)[a\mapsto \alpha, b\mapsto \beta] \\
&\quad (\beta-\alpha-2^{n-1}\leq 0) \to 
\label{eq:terminate}\\
&\quad \qquad (\forall \omega.\; (\omega = 0\land 2^n < \beta - \alpha) 
\lor (\omega = 1 \land \beta-\alpha> 2^{n-1})
\to \omega = 0) \nonumber
\end{align}
Proposition \ref{eq:init} is exactly the proposition which we have added to our theory.
$uniq(\alpha, \beta)$ assures that there is an unique root in $[\alpha, \beta]$ and
$2^n<\beta-\alpha$ ensures that the distance between $\alpha$ and the 
root is less than $2^n$; hence, Proposition \ref{eq:postinfer} can be proven.
Having $2^n>2^{n-1}>0$ ensures $\forall x.\; 2^n>x\lor x > 2^{n-1}$; hence,
Proposition \ref{eq:safety} can be proven as well.
Proposition \ref{eq:terminate} can be easily proven by case distinction.

Now, let us see what happens inside the loop (Proposition \ref{eq:invar}).
See that $vc(S, uniq(a,b)\land b-a\leq c-c_0)[a\mapsto \alpha, b \mapsto \beta]$ can be 
evaluated to be the following propositions quantified by $\forall c.\;\exists c_0.$:
\begin{align*}
&f\left(\frac{\alpha+2\cdot \beta}{3}\right) > 0 \lor
 f\left(\frac{2\cdot \alpha+ \beta}{3}\right) < 0 \\
& f\left(\frac{2\cdot \alpha+ \beta}{3}\right) < 0
\to uniq((2\cdot\alpha+\beta)/3, \beta) \land \frac{2}{3}(\beta-\alpha) \leq c-c_0\\
&f\left(\frac{\alpha+2\cdot \beta}{3}\right) > 0 \to 
uniq(\alpha, (\alpha+2\cdot\beta)/3) \land \frac{2}{3}(\beta-\alpha)  \leq c - c_0
\end{align*}

Letting $c_0 := 2^{n-3}$, 
together with Intermediate Value Theorem and the uniqueness of the root in $[\alpha,\beta]$,
we can ensure the three propositions.


\section{Implementation: \texttt{erc-vc-extract}}
\texttt{erc-vc-extract}, a verification condition extractor 
is implemented in \texttt{ocaml} using \texttt{yacc} parser generator.
Given a pre/postcondition and loop in/variant annotated ERC program, 
\texttt{erc-vc-extract} generates a \texttt{Coq} file which contains
the extracted verification condition of the annotated ERC program;
a user can prove the statements in \texttt{Coq} to verify the input ERC program.

\texttt{erc-vc-extract} reduces the trivial quantifiers (see Section \ref{ss:semterm}) and
produces a text file includes how the quantifiers are reduced for each term.

The source code of \texttt{erc-vc-extract} can be found in \url{http://erc.realcomputation.asia/wc-extract}.
As a prototype of the development, 
annotated Trisection program \texttt{trisection.erc} was written, and ran by the extractor.
The produced \texttt{Coq} file \texttt{trisection.v} contains more or less the same propositions
mentioned in Section \ref{ss:triverif}, and the verification conditions are proved in \texttt{Coq};
proof of it is contained in \texttt{trisection\_proved.v} file. The example codes and proofs are 
also accessible in the provided url.




\end{document}


\subsection{Weakest Precondition}
Weakest precondition of a well--typed statement 
and a predicate is the ``\textit{weakest}'' predicate  
in sense that it defines as most initial states, when the statement's 
semantic is acted on it, the result is a proper set of states where each satisfies the given predicate.
Formally speaking, the weakest precondition of a well--typed statement is a function
\[
wp(\Gamma \vdash S \triangleright \Gamma',-) : Pred(\sem{\Gamma'}) \to Pred(\sem{\Gamma})
\]
which defines preconditions such that
\[
\forall \sigma \in \sem{\Gamma}.\; wp(\Gamma \vdash S \triangleright \Gamma',Q) (\sigma)
\leftrightarrow
\bot\not\in\sem{S}\sigma \land \forall \delta \in \sem{S}\sigma.\; Q(\delta).
\]

\begin{flalign*}
% empty
&wp(\epsilon, Q) = Q &\\
% variable assignment
&wp(v := t, Q) = \exists w.\;\trans{t}(w)\land \forall w.\; \trans{t}(w) \to Q[v\mapsto w]&\\
% array assignment
&wp(T[z] := t, Q) =
(\exists n\;w.\;\trans{z}(n)\land\trans{t}(w))\land&\\
&\qquad\qquad\qquad\qquad
\land(\forall n.\;\trans{z}(n)\to 0\leq n < d)&\\
&\qquad\qquad\qquad\qquad
\land(\forall n\;w.\; \trans{z}(n)\land\trans{t}(w) \to Q[T \mapsto T\twoheadrightarrow_n w])&\\
% variable declaration
&wp(\textbf{newvar}\;v := t, Q) =  \exists w.\; \trans{t}(w) \land \forall w.\; \trans{t}(w) \to Q[T\mapsto w]&\\
% sequence
&wp(S_1; S_2, Q) = wp(S_1, wp(S_2, Q))&\\
% conditional
&wp(\textbf{if}\;z\;\textbf{then}\; S_1 \; \textbf{else}\; S_2, Q) =&\\
&\qquad\qquad\exists k. h(z)(k) \land
(\exists k\neq0.\; h(z)(k) \to wp(S_1, Q))\land
(h(z)(0) \to wp(S_2, Q))&\\
% loop
&wp(\textbf{while}\;z\;\textbf{do}\; S, Q) = &\\
&\qquad\qquad I \land &\\
&\qquad\qquad\forall\;\mathbf{v}.\;&\\
&\qquad\qquad\quad\quad(I \land h(z)(0) \to Q)  &\\
&\qquad\qquad\quad\land I \to (\exists k. h(z)(k))  &\\
&\qquad\qquad\quad\land\exists c_0. \forall c.\; (I \land (\exists k\neq0.\; h(z)(k)) \land (V = c) \to wp(S, I \land V \leq c - c_0))&\\
&\qquad\qquad\quad\land V \leq 0 \to (\forall v.\;h(z)(v) \to v=0)
\end{flalign*}
Above $\mathbf{v}$ represents the set of variables that gets assigned in $S$.
the first clause $I$ denotes that the loop invariant $I$ should hold at the beginning of the loop;
other clauses are conditions that should be satisfied throughout any stages of the loop.


\begin{theorem}
The introduced function $wp$ is indeed the weakest precondition
\end{theorem}
\begin{proof}
$\longrightarrow$ part of the proof can be done using the same arguments from the proof of soundness of Hoare logic.

\noindent[conditional]
\newline
\noindent
%Let $\sigma$ satisfies the weakest precondition. 
%Then, $\bot\not\in\sem{z}\sigma$ finite. 
%If $\{0, k\}\subseteq\sem{z}\sigma$ for some nonzero $k$, then $\exists k\neq.\; \trans{z}(k)$ and $\trans{z}(0)$
%both hold. 
%Therefore, $wp(S_1, Q)$ and $wp(S_2, Q)$ which means that 
%$\bot\not\in\sem{S_1}\sigma\land \forall \delta \in\sem{S_1}.\;Q(\delta)$ and
%$\bot\not\in\sem{S_2}\sigma\land \forall \delta \in\sem{S_2}.\;Q(\delta)$.
%Hence, according to the semantic definition, the conditional statement yields a proper set of 
%states that each satisfies $Q$. other cases can be done similarly.

Suppose $\sigma$ does not satisfy the weakest precondition.
Then, at least one of $\bot\in\sem{z}\sigma$, $\exists k\neq0.h(z)(k) \to wp(S_1, Q)$ or 
$\trans{z}(0) \to wp(S_2, Q)$ is false.
If $\bot\in\sem{z}\sigma$ then the $\bot\in\sem{\textbf{if}\cdots}\sigma$.
If $\trans{z}(0) \to wp(S_2, Q)$ is false; $0\in\sem{z}\sigma$ and $wp(S_2, Q)\to \text{false}$. As $0\in\sem{z}\sigma$, hence $\sem{S_2}\sigma\subseteq\sem{\textbf{if}\cdots}\sigma$.
By the hypothesis of the structural induction, there is at least one state in $\sem{S_2}$ that is either $\bot$ or does not satisfy 
$Q$. The other case can be done similarly.

 \vspace{1em}
 \noindent[loop] (\textit{Sketch.})
 \newline
 \noindent
 $\bot\not\in\sem{\textbf{while}\cdots}\sigma$ only if
 there is some $n$ such that $\bot\not\in\omega_n\sigma$ finite
 such that $\omega_n\sigma = \omega_{n+1}\sigma = \cdots$. 
 The $n$ being a function of $\omega$ can be the loop variant.
 
\end{proof}

\subsection{Program Verification}
Recall that a ERC program is in the following format:

\begin{flalign*}
&P := &\\
&\qquad\textbf{input}\;v_1 : \tau_1, v_2 : \tau_, \cdots, v_n : \tau_n &\\
&\qquad S &\\
&\qquad\textbf{return}\;t& 
\end{flalign*}

Considering that the program $P$ is well--typed, we have 
$\Gamma_0 \vdash S \triangleright \Gamma$ and $\Gamma \vdash t : \tau$
where $\Gamma_0 = \cup_i (v_i \to \tau_i)$ with some $\tau$.

Precondition of a program is a predicate that defines a set of input values of the input variables.
Postcondition should be a predicate on the input values of the input variables and their return value.
Hence, $Pre : Pred(\sem{\Gamma_0})$ and $Post : Pred(\sem{\tau}\times\sem{\Gamma_0})$.

Now, let us consider what predicate should hold at the end of the statement 
in order to guarantee $Post$.
One thing to make sure is that the semantic of the returning term to be proper and all of its elements to satisfy $Post$:
\[\exists r.\;\trans{t}(r)\land \forall r,\;\trans{t}(r)\to Post(r,\cdots)\]
However, the above modification is wrong since the
variables in the postcondition should refer to the initial values that the input variables had
not the values that the input variables are storing at the moment.

To make sure the variables in $Post$ refer to the initial values, we can alter the variables:
\[\exists r.\;\trans{t}(r)\land \forall r,\;\trans{t}(r)\to Post[v_i \mapsto v_i'](r)\]
We can compute the weakest precondition on the above predicate.
Since $v_i'$ refers to the initial values, at the end of the weakest precondition calculus, 
we can reset those altered variable back again;
program verification using the weakest precondition calculus is to prove
\[
Pre \to wp(S, \exists r.\;\trans{t}(r)\land \forall r,\;\trans{t}(r)\to Post(r)[v_i\mapsto v_i'])[v_i'\mapsto v_i]
\]

