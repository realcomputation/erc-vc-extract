
(***********)
(*
 *  This is a Coq source code generated by ERC-wp-calc.
 *  ERC-wp-calc is a program extracts correctness conditions written by Sewon Park @ KAIST.
 *  If you see the message it means that the extraction program is at its stage of prototype.
 *  Any feedback or bug report will be appreciated! :)
 *)

(***********)
(*
 *  The program uses ***_prec.v which contains definition of prec (precision embedding) function and
 *  some may useful lemmas and their proofs:
 *
 * - prec : Z -> R such that prec z means 2^z
 * - Lemma prec_pos : forall z : Z, prec z > 0.
 * - Lemma prec_mult : forall z1 z2 : Z, prec (z1 + z2) = prec z1 * prec z2.
 * - Lemma prec_div : forall z1 z2 : Z, prec(z1 - z2) = prec z1 */ prec z2.
 *
 *  ***_prec.v can be loaded after compiling it "coqc ***_prec.v"
 *)
 
Require Import Reals.
Require Import ZArith.
Require Import trisection_prec.



(* Proving correctness of the following program:
 *
 * Precondition: True
 *
 * Input:  p : Z
 *
 * Newvar a := 0
 * Newvar b := 1
 * while (Choose(test(iota(p)>b + -a), test(b + -a>iota(p + -1))))
 * do
 *  if(Choose(test(f(a + 2 * b * /3)>0), test(0>f(2 * a + b * /3))))
 *  then
 *   assign a := 2 * a + b * /3
 *  else
 *   assign b := a + 2 * b * /3
 *
 * Return a
 *
 * Postcondition: (((1>@res)%R /\ (@res>0)%R) /\ exists root : R, ((((f root )=0)%R /\ (((prec p)>(root + - @res))%R /\ ((root + - @res)>- (prec p))%R))))*)


(**********)
(* Single valued functions loaded to the language *)

Parameter f : R   -> R.



(**********)
(* Definition of predicates *)

Definition uniq (_in1435 : R)(_in1436 : R) := ((((((1>_in1435)%R /\ (_in1435>0)%R) /\ ((1>_in1436)%R /\ (_in1436>0)%R)) /\ (_in1436>_in1435)%R) /\ (((f _in1436 )>0)%R /\ (0>(f _in1435 ))%R)) /\ exists z : R, (((((_in1436>z)%R /\ (z>_in1435)%R) /\ ((f z )=0)%R) /\ forall _uniqz2 : R, (((((_in1436>_uniqz2)%R /\ (_uniqz2>_in1435)%R) /\ ((f _uniqz2 )=0)%R) -> (z=_uniqz2)%R))))).




(**********)
(* Assumed axioms *)

Axiom axiom6 : 
	(uniq 0 1 ).

Axiom axiom7 : 
	forall _v1 : R, ((True -> (((f 1 )>0)%R /\ (0>(f 0 ))%R))).




(**********)
(* Assumed Coq axioms *)

Axiom axiomCoq5 : 
	 continuity f.


(**********)
(* put your supplementary lemmas and definitions here *)
Lemma overlap_interval_r : forall r1 r2 : R, r2 > 0 -> r1 < r2 \/ r1 > r2 */ 2.
Proof.
  intros r1 r2.
  case (Rle_lt_dec r1 r2).
  intros r H; destruct r.
  (* case 1: r1 < r2 *)
  left; exact H0.
  (* case 2: r1 = r2 *)
  right.
  rewrite H0.
  pose proof (Rmult_gt_compat_r (/2) (r2*2) (r2) ).
  assert (/2 > 0).
  assert (2>0).
  prove_sup.
  exact (Rinv_0_lt_compat 2 H2).
  apply H1 in H2.
  rewrite (Rmult_assoc) in H2.
  assert (2 <> 0).
  discrR.
  rewrite (Rinv_r 2 H3) in H2; rewrite (Rmult_1_r r2) in H2; exact H2.
  apply (Rplus_gt_compat_r r2 r2 0) in H.
  rewrite  <- (Rmult_1_r r2) in H at 1 2.
  rewrite Rplus_0_l in H.
  rewrite <- (Rmult_plus_distr_l r2 1 1) in H.
  exact H.
  (* case 3: r1 > r2 *)
  intros r H; right; apply (Rlt_gt) in r.
  assert (r2 *2 > r2).      
  apply (Rplus_gt_compat_r r2 r2 0) in H.
  rewrite <- (Rmult_1_r r2) in H at 1 2.
  rewrite <- (Rmult_plus_distr_l r2 1 1) in H.
  rewrite Rplus_0_l in H.
  exact H.
  pose proof (Rmult_gt_compat_r (/2) (r2*2) (r2) ).
  assert (/2 > 0).
  assert (2>0).
  prove_sup.
  exact (Rinv_0_lt_compat 2 H2).
  apply (H1 H2) in H0.
  rewrite (Rmult_assoc) in H0.
  assert (2 <> 0).
  discrR.
  rewrite (Rinv_r 2 H3) in H0.
  rewrite (Rmult_1_r) in H0.
  exact (Rgt_trans r1 r2 ( r2 * / 2) r H0).
Qed.  


Lemma convex_sum : forall x y a b: R, x < y -> a>0->b>0-> x<(a*x + b*y)*/(a+b)<y.
Proof.
  intros x y a b H H0 H1; constructor.
  (* subgoal 1: left inequality *)
  assert (triv : a + b > 0).
  exact (Rlt_gt 0 (a+b) (Rplus_lt_0_compat a b (Rgt_lt a 0 H0) (Rgt_lt b 0 H1))).
  apply (Rmult_lt_reg_r (a + b) x ((a * x + b * y) * / (a + b)) triv).
  pose proof (Rgt_not_eq (a+b) 0 triv).
  rewrite (Rmult_assoc (a * x + b * y) ( / (a + b)) (a + b)).
  rewrite <- (Rinv_l_sym (a + b) H2).
  rewrite (Rmult_1_r (a * x + b * y)).
  rewrite (Rmult_plus_distr_l x a b).
  rewrite (Rmult_comm x a).
  apply (Rplus_lt_compat_l (a*x) (x*b) (b*y)).
  rewrite (Rmult_comm b y). 
  exact (Rmult_lt_compat_r b x y (Rgt_lt b 0 H1) H).

  (* subgoal 2: right inequality *)
  assert (triv : a + b > 0).
  exact (Rlt_gt 0 (a+b) (Rplus_lt_0_compat a b (Rgt_lt a 0 H0) (Rgt_lt b 0 H1))).
  apply (Rmult_lt_reg_r (a + b) ((a * x + b * y) * / (a + b)) y triv).
  pose proof (Rgt_not_eq (a+b) 0 triv).
  rewrite (Rmult_assoc (a * x + b * y) ( / (a + b)) (a + b)).
  rewrite <- (Rinv_l_sym (a + b) H2).
  rewrite (Rmult_1_r (a * x + b * y)).
  rewrite (Rmult_plus_distr_l y a b).
  rewrite (Rmult_comm y b).
  apply (Rplus_lt_compat_r (b*y) (a*x) (y*a)).
  rewrite (Rmult_comm y a). 
  exact (Rmult_lt_compat_l a x y (Rgt_lt a 0 H0) H).
Qed.

Lemma g_IVT : forall (f : R -> R) (x y : R), 
    continuity f -> x < y -> (f x) * (f y) < 0 -> {z : R | x <= z <= y /\ f z = 0}.
Proof.
  intros f x y H H0 H1.
  pose proof (Rtotal_order (f x) 0).
  case (Rle_lt_dec (f x ) 0).
  intro r.
  case (Rle_lt_or_eq_dec (f x) 0 r).
  (* case 1: f x < 0 < f y *)
  intuition.
  rewrite <- (Rmult_0_r (f x)) in H1.
  apply (Ropp_lt_gt_contravar (f x * f y) (f x * 0) ) in H1.
  rewrite (Ropp_mult_distr_l (f x)  (f y)) in H1. 
  rewrite (Ropp_mult_distr_l (f x)  0) in H1.
  pose proof (Ropp_lt_gt_contravar (f x) (0) r0).
  rewrite (Ropp_0) in H3.
  pose proof (Rmult_lt_reg_l (- f x)  0 (f y) (Rgt_lt (- f x) 0 H3) (Rgt_lt (- f x * f y) (- f x * 0) H1)).
  exact (IVT f x y H H0 r0 H4).
  (* case 2: f x = 0; contradiction *)
  intuition.
  rewrite e in H1.
  rewrite (Rmult_0_l (f y)) in H1.
  contradict H1.
  apply Rlt_irrefl.
  (* case 3: f x > 0 > f y *)
  intuition.
  rewrite <- (Rmult_0_r (f x)) in H1.
  apply (Rmult_lt_reg_l (f x) (f y) 0 r) in H1.
  assert (continuity (opp_fct f)).
  exact (continuity_opp f H).
  assert (opp_fct f x < 0).
  unfold opp_fct.
  pose proof (Rplus_lt_reg_l (f x) (- f x) (0)).
  rewrite (Rplus_opp_r (f x)) in H4.
  apply H4.
  rewrite (Rplus_0_r (f x)).
  exact r.
  assert (0 < opp_fct f y).
  unfold opp_fct.
  pose proof (Rplus_lt_reg_l (f y) (0) (- f y)).
  rewrite (Rplus_opp_r (f y)) in H5.
  apply H5.
  rewrite (Rplus_0_r (f y)).
  exact H1.
  pose proof (IVT (opp_fct f) x y H3 H0 H4 H5).
  unfold opp_fct in H6.
  elim H6.
  intuition.
  exists x0.
  constructor.
  constructor.
  intuition.
    intuition.
    apply (Ropp_eq_0_compat (- f x0)) in H8.
    rewrite (Ropp_involutive (f x0)) in H8.
    exact H8.
  Qed.

Lemma s_IVT :
  forall (f : R -> R) (x y : R), continuity f -> x < y -> f x < 0 -> 0 < f y -> exists z : R, x < z < y /\ f z = 0.
Proof.
  intros a b c d e f g.
  destruct (IVT a b c d e f g) as [root [ors conds]].
  exists root.
  split.
  destruct ors.
  destruct H.
  destruct H0.
  auto.
  rewrite H0 in conds.
  rewrite conds in g.
  contradict g; exact (Rlt_irrefl 0).
  rewrite <- H in conds.
  rewrite conds in f.
  contradict f; exact (Rlt_irrefl 0).
  exact conds.
Qed.

Lemma w_IVT :
  forall (f : R -> R) (x y : R), continuity f -> x < y -> f x <= 0 -> 0 <= f y -> exists z : R, x <= z <= y /\ f z = 0.
Proof.
  intros a b c d e f g.
  destruct f as [f | f].
  destruct g as [g | g].
 
  destruct (IVT a b c d e f g) as [root conds].
  exists root; auto.
  exists c.
  split; auto.
  split; auto.
  left; auto.
  right; auto.
  exists b.
  split; auto.
  split; auto.
  right; auto.
  left; auto.
Qed.

Lemma uniq_refinement : forall (x a b y : R), 
    uniq x y -> a < b -> x <= a -> b <= y -> f a  <0 ->  0 < f b
    -> uniq a b.
Proof.
  intros x a b y H H0 H1 H2 H3 H4.

  pose proof (s_IVT f a b axiomCoq5  H0 H3 H4).
  unfold uniq.
  split.
  split.

  split; auto.
  destruct H as [[[[[p q] [r s]]  _] _] _].
  split.
  split.
  pose proof (Rlt_le_trans a b y H0 H2).
  apply (Rlt_trans a y); auto.
  apply (Rlt_le_trans 0 x); auto.
  split.
  apply (Rle_lt_trans b y); auto.
  pose proof (Rlt_le_trans 0 x a q H1).
  apply (Rlt_trans 0 a); auto.
  split; auto.

  destruct H5 as [root [condl condr]].
  exists root.
  split.
  split; auto.
  destruct condl; auto.

  intros othe [[oc1 oc2] oc3].
  destruct H as [_ [uroot [_ uni]]].

  pose proof (uni root).
  assert (root_cond :(y > root /\ root > x) /\ f root = 0).
  split; auto.
  split.
  destruct condl.
  apply (Rlt_le_trans root b); auto.
  apply (Rle_lt_trans x a); auto.
  destruct condl; auto.
  apply H in root_cond.

  pose proof (uni othe).
  assert (othe_cond :(y > othe /\ othe > x) /\ f othe = 0).
  split; auto.
  split.
  apply (Rlt_le_trans othe b); auto.
  apply (Rle_lt_trans x a); auto.
  apply H5 in othe_cond.
  rewrite <- root_cond, othe_cond; exact eq_refl.
Qed.  
  


(**********)
(* Theorems to be proven *)

Theorem theorem0 : 
	(uniq 0 1 ).
Proof.
  exact axiom6.
Qed.

Theorem theorem1 : 
	forall p : Z, (forall _b1432 : R, (forall _a1431 : R, ((((((uniq _a1431 _b1432 ) /\ ((prec p)>(_b1432 + - _a1431))%R) -> (1>_a1431)%R) /\ (((uniq _a1431 _b1432 ) /\ ((prec p)>(_b1432 + - _a1431))%R) -> (_a1431>0)%R)) /\ (((uniq _a1431 _b1432 ) /\ ((prec p)>(_b1432 + - _a1431))%R) -> exists root : R, ((((f root )=0)%R /\ (((prec p)>(root + - _a1431))%R /\ ((root + - _a1431)>- (prec p))%R)))))))).
Proof.
  intros p b a.
  split.
  split.

  intros [q _].
  unfold uniq in q.
  destruct q as [[[[[c _] _]  _] _] _].
  exact c.

  intros [q _].
  unfold uniq in q.
  destruct q as [[[[[_ c] _]  _] _] _].
  exact c.

  intros [q r].
  unfold uniq in q.
  destruct q as [c d].
  destruct d as [root prv].
  exists root.
  split.
  destruct prv as [[_ ans] _]; exact ans.
  destruct prv as [[[or1 or2] _ ] _ ].
  split.
  apply (Rplus_gt_compat_r (-a)) in or1.
  exact (Rgt_trans (prec p) (b+-a) (root +-a) r or1).
  pose proof (prec_pos p).
  apply (Rplus_gt_compat_r (-prec p)) in H.
  ring_simplify in H.
  apply (Rplus_gt_compat_r (-a)) in or2.
  ring_simplify in or2.
  exact (Rgt_trans (root+-a) 0 (-prec p) or2 H).
Qed.

Theorem theorem2 : 
	forall p : Z, (forall _b1430 : R, (forall _a1429 : R, (((uniq _a1429 _b1430 ) -> (((prec p)>(_b1430 + - _a1429))%R \/ ((_b1430 + - _a1429)>(prec (p + - 1)))%R))))).
Proof.
  intros p  b a.
  intros _.
  replace (p+-1)%Z with (p-1)%Z by ring.
  rewrite prec_div.
  simpl.
  replace (2*1) with 2 by ring.
  exact (overlap_interval_r (b+-a) (prec p) (prec_pos p)).
Qed.

Theorem theorem3 : 
	forall p : Z, (forall _b1428 : R, (forall _a1427 : R, (exists _loopc08 : R, ((((uniq _a1427 _b1428 ) /\ ((_b1428 + - _a1427)>(prec (p + - 1)))%R) -> ((((f ((_a1427 + (2 * _b1428)) * (-1 * / -3)) )>0)%R \/ (0>(f (((2 * _a1427) + _b1428) * (-1 * / -3)) ))%R) /\ (((0>(f (((2 * _a1427) + _b1428) * (-1 * / -3)) ))%R -> ((uniq (((2 * _a1427) + _b1428) * (-1 * / -3)) _b1428 ) /\ ((((_b1428 + - _a1427) + - (prec (p + - 1))) + - _loopc08)>((_b1428 + - (((2 * _a1427) + _b1428) * (-1 * / -3))) + - (prec (p + - 1))))%R)) /\ (((f ((_a1427 + (2 * _b1428)) * (-1 * / -3)) )>0)%R -> ((uniq _a1427 ((_a1427 + (2 * _b1428)) * (-1 * / -3)) ) /\ ((((_b1428 + - _a1427) + - (prec (p + - 1))) + - _loopc08)>((((_a1427 + (2 * _b1428)) * (-1 * / -3)) + - _a1427) + - (prec (p + - 1))))%R))))))))).
Proof.
  intros p b a.
  exists (prec (p-3)).
  intros [I cond].
  split.

  (* loop invariant -> f(a') < 0 \/ f(b') > 0 *)
  destruct (Rlt_or_le 0  ( f ((a + 2 * b) * (-1 * / -3)))).
  left; exact H.
  destruct (Rlt_or_le (f ((2 * a + b) * (-1 * / -3))) 0 ).
  right; exact H0.

  unfold uniq in I.
  destruct I as [[[_ q] [fb fa]] [ex [con uni]]].

  replace (-1*/-3) with (/(2+1)) in H, H0 by field.
  assert (t1 : 2 > 0) by omega_sup.
  assert (t2 : 1 > 0) by omega_sup.
  destruct  (convex_sum a b 2 1 q t1 t2) as [or1 or2].
  clear t1.
  clear t2.
  replace (2 * a + 1 * b) with (2*a + b) in or1, or2 by ring.  
  assert (fal :  f a <= 0) by (left; auto).
  destruct (w_IVT f a ((2 * a + b) * / (2 + 1)) axiomCoq5 or1 fal H0) as [root1 cond1].

  assert (t1 : 2 > 0) by omega_sup.
  assert (t2 : 1 > 0) by omega_sup.
  destruct  (convex_sum a b 1 2 q t2 t1) as [orb1 orb2].
  clear t1.
  clear t2.
  replace (1 * a + 2 * b) with (a +2*b) in orb1, orb2 by ring.
  assert (fbr : 0<=f b) by (left; auto).
  replace (2+1) with (1+2) in H by ring.
  destruct (w_IVT f ((a + 2 * b) * / (1 + 2)) b axiomCoq5 orb2 H fbr) as [root2 cond2].
  assert (fat : root1 = root2).
  clear cond H H0.

  assert (root1cond : ((b > root1 /\ root1 > a) /\ f root1 = 0)).
  destruct cond1 as [[pl pr] roota].

  split; auto.
  split.
  destruct pr.
  exact (Rlt_trans root1 ((2 * a + b) * / (2 + 1)) b H or2).
  rewrite <- H in or2.
  exact or2.
  destruct pl; auto.
  rewrite <- H in roota.
  rewrite roota in fa.
  contradict fa; exact (Rlt_irrefl 0).

  assert (root2cond : ((b > root2 /\ root2 > a) /\ f root2 = 0)).
  destruct cond2 as [[ql qr] rootb].

  split; auto.
  split.
  destruct qr; auto.
  rewrite  H in rootb.
  rewrite rootb in fb.
  contradict fb; exact (Rlt_irrefl 0).
  destruct ql.
  
  exact (Rlt_trans a ( (a + 2 * b) * / (1 + 2)) root2 orb1 H).
  rewrite H in orb1; auto.

  pose proof (uni root1 root1cond) as r1.
  pose proof (uni root2 root2cond) as r2.
  rewrite <-r1, r2; exact eq_refl.
  assert (orc : (2 * a + b) * / (2 + 1) < (a + 2 * b) * / (1 + 2)).
  replace (2+1) with 3 by ring.
  replace (1+2) with 3 by ring.
  apply Rmult_lt_compat_r.
  apply Rinv_0_lt_compat.
  omega_sup.
  replace (2*a+b) with ((a) + (a+b)) by ring.
  replace (a+2*b) with (b + (a+b)) by ring.
  apply Rplus_lt_compat_r;auto.
  destruct cond1 as [[_ pa] _].
  destruct cond2 as [[pb _] _].
  rewrite fat in pa.
  pose proof (Rle_trans ((a + 2 * b) * / (1 + 2)) root2 ((2 * a + b) * / (2 + 1)) pb pa).
  contradict H1.
  apply Rgt_not_le; auto.
                


  (* cases for if-then-else statement *)
  split.
  intro cas.
  split.
  (* loop invariant *)

  pose proof (uniq_refinement a ((2 * a + b) * (-1 * / -3)) b b I).
  destruct I as [[[[_  u1] u2] [ u3 _] ] _].

  replace (-1*/-3) with (/(2+1)) in H, cas by field.
  assert (t1 : 2 > 0) by omega_sup.
  assert (t2 : 1 > 0) by omega_sup.
  destruct  (convex_sum a b 2 1 u2  t1 t2) as [or1 or2].
  clear t1.
  clear t2.
  replace (2*a+1*b) with (2*a+b) in or2 by ring.
  apply H in or2.
  replace (-1*/-3) with (/(2+1)) by field; exact or2.
  replace (2*a+1*b) with (2*a+b) in or1 by ring.
  left; exact or1.
  right; exact eq_refl.
  exact cas.
  exact u3.
  
  (* loop variant *)
  ring_simplify.
  field_simplify.
  apply (Rplus_gt_reg_l ((-2 * b + 2 * a + 3 * prec (p + -1)) / 3)).
  field_simplify.
  replace (0/-9) with (0*/-9) by auto.
  ring_simplify.
  replace ((b - a - 3 * prec (p - 3)) / 3) with ((b - a - 3 * prec (p - 3)) */ 3) by auto.
  replace 0 with (0*/3) by ring.
  apply Rmult_gt_compat_r.
  apply Rinv_0_lt_compat; omega_sup.
  replace (b - a - 3 * prec (p - 3)) with ((b - a) + (- 3 * prec (p - 3))) by ring.
  replace 0 with ((3 * prec (p - 3)) +(-3 * prec (p - 3))) by ring.
  apply Rplus_lt_compat_r.
  assert (3*prec(p-3)<prec (p-1)).
  replace (p-3)%Z with ((p-1)-2)%Z by ring.
  rewrite (prec_div (p-1) 2).
  replace (3 * (prec (p - 1) * / prec 2)) with ((3 * /prec 2) * (prec (p - 1))) by ring.
  replace (prec (p-1)) with (1 *prec (p-1)) at 2 by ring.
  apply (Rmult_gt_compat_r).
  apply prec_pos.
  pose proof (Rinv_r_sym (prec 2)).
  assert (prec 2 <> 0).
  simpl.
  discrR.
  apply H in H0.
  rewrite H0.
  apply Rmult_gt_compat_r.
  apply (Rinv_0_lt_compat); apply prec_pos.
  simpl; ring_simplify; omega_sup.

  replace(b+-a) with (b-a) in cond by auto.
  replace (p+-1)%Z with (p-1)%Z in cond by auto.
  apply (Rlt_trans ( 3 * prec (p - 3)) (prec (p-1))); auto.


  (* case2 *)
  intro cas.
  split.
  (* loop invariant *)

  pose proof (uniq_refinement a a ((a + 2*b) * (-1 * / -3)) b I).
  destruct I as [[[[_  u1] u2] [_ u3] ] _].

  replace (-1*/-3) with (/(1+2)) in H, cas by field.
  assert (t1 : 2 > 0) by omega_sup.
  assert (t2 : 1 > 0) by omega_sup.
  destruct  (convex_sum a b 1 2 u2 t2 t1) as [or1 or2].
  clear t1.
  clear t2.
  replace (1*a+2*b) with (a+2*b) in or1, or2 by ring.
  apply H in or1.
  replace (1+2) with (2+1) in or1 by ring.
  replace (-1*/-3) with (/(2+1)) by field; exact or1.
  right; exact eq_refl.
  left; exact or2.
  exact u3.
  exact cas.
  
  (* loop variant *)
  ring_simplify.
  field_simplify.
  apply (Rplus_gt_reg_l ((-2 * b + 2 * a + 3 * prec (p + -1)) / 3)).
  field_simplify.
  replace (0/-9) with (0*/-9) by auto.
  ring_simplify.
  replace ((b - a - 3 * prec (p - 3)) / 3) with ((b - a - 3 * prec (p - 3)) */ 3) by auto.
  replace 0 with (0*/3) by ring.
  apply Rmult_gt_compat_r.
  apply Rinv_0_lt_compat; omega_sup.
  replace (b - a - 3 * prec (p - 3)) with ((b - a) + (- 3 * prec (p - 3))) by ring.
  replace 0 with ((3 * prec (p - 3)) +(-3 * prec (p - 3))) by ring.
  apply Rplus_lt_compat_r.
  assert (3*prec(p-3)<prec (p-1)).
  replace (p-3)%Z with ((p-1)-2)%Z by ring.
  rewrite (prec_div (p-1) 2).
  replace (3 * (prec (p - 1) * / prec 2)) with ((3 * /prec 2) * (prec (p - 1))) by ring.
  replace (prec (p-1)) with (1 *prec (p-1)) at 2 by ring.
  apply (Rmult_gt_compat_r).
  apply prec_pos.
  pose proof (Rinv_r_sym (prec 2)).
  assert (prec 2 <> 0).
  simpl.
  discrR.
  apply H in H0.
  rewrite H0.
  apply Rmult_gt_compat_r.
  apply (Rinv_0_lt_compat); apply prec_pos.
  simpl; ring_simplify; omega_sup.

  replace(b+-a) with (b-a) in cond by auto.
  replace (p+-1)%Z with (p-1)%Z in cond by auto.
  apply (Rlt_trans ( 3 * prec (p - 3)) (prec (p-1))); auto.
Qed.

Theorem theorem4 : 
	forall p : Z, (forall _b1426 : R, (forall _a1425 : R, (((0>((_b1426 + - _a1425) + - (prec (p + - 1))))%R -> (((_b1426 + - _a1425)>(prec (p + - 1)))%R -> False))))).
Proof.
  intros p b a q.
  apply (Rplus_gt_compat_r (prec (p+-1))) in q.
  ring_simplify in q.
  contradict q.
  apply Rgt_ge in q.
  apply Rge_not_gt in q.
  auto.
Qed.

